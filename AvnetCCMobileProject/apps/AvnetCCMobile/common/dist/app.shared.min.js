/**
 * @name homeController
 * @desc Home controller
 */
(function() {
  'use strict';
homeController.$inject = ['$scope', '$rootScope', 'userService', 'CONST'];
  angular.module('ccMobile')
    .controller('homeController', homeController);

  function homeController($scope, $rootScope, userService, CONST) {
    console.log('homeController: load');
    
    // bindable variables
    $scope.permissions = userService.userData.permissions;
    $scope.tools = CONST.TOOLS;

    // internals

    function activate() {    	
      console.log('homeController: activate');
      $rootScope.busyInd.hide();
    }

    activate();
}

})();

(function () {
    'use strict';
    loginController.$inject = ['$scope', 'userService', 'CONST', '$state', '$timeout', '$rootScope', '$interval', 'newRequestFactory', 'quoteDetailFactory'];
    angular.module('ccMobile')
        .controller('loginController', loginController);

    /**
     * login controller main function
     */
    function loginController($scope, userService, CONST, $state, $timeout, $rootScope, $interval, newRequestFactory, quoteDetailFactory) {

        console.log('loginController: load');

        //bindable vars
        $scope.user = {};
        $scope.user.userNameError = {};
        $scope.user.passwordError = {};
        $scope.webViewOverlayShown = false;
        $scope.hideForgotCredentials = false;
        $scope.networkConnected = true;


        //bindable methods
        $scope.setFocus = setFocus;
        $scope.validateInput = validateInput;
        $scope.toggleWebViewShown = toggleWebViewShown;
        $scope.login = login;


        //internal vars

        var isLocalDev = CONST.LOCAL;


        //internal funcs

        function activate() {
            console.log('loginController: activate');
            clearSessionData();
            $rootScope.busyInd.hide();
        }

        function clearSessionData() {
            console.log('loginController: clearSessionData');
            $rootScope.modalShown = undefined;
            $rootScope.showDetailsHeaderButton = false;
            newRequestFactory.resetNewRequest();
            quoteDetailFactory.quoteDetailData = undefined;
            quoteDetailFactory.quoteDetailEndUserClicked = undefined;
            quoteDetailFactory.addNoteSendNotificationClicked = undefined;
        }

        /**
         * submit Login function
         */
        function submitLoginForm() {
            console.log('loginController: login');
            if (!$rootScope.busyInd.isVisible()) {
                $rootScope.busyInd.show();
            }
            console.log('submitLoginForm: ', $scope.user);

            var reqURL = '/../../../pkmslogin.form';
            var options =
            {
                headers: {},
                parameters: {
                    username: $scope.user.userName,
                    password: $scope.user.password,
                    'login-form-type': 'pwd'
                }
            };
            username = $scope.user.userName;
            password = $scope.user.password;
            HeaderAuthRealmChallengeHandler.submitLoginForm(reqURL, options, handleSubmit);
        }


        /**
         * login function
         */
        function login(loginForm) {
            console.log('loginController: login: ', $scope.user);
            setBlur('username');
            setBlur('password');
            if ($scope.user.userName == undefined || $scope.user.password == undefined || $scope.user.userName == "" || $scope.user.password == "") {
                if ($scope.user.password == undefined) {
                    $scope.user.passwordError.missingInput = true;
                    addTransition('password');
                }

                if ($scope.user.userName == undefined) {
                    $scope.user.userNameError.missingInput = true;
                    addTransition('username');
                }
            } else {

                userService.userData.id = $scope.user.userName;

                if (!$rootScope.busyInd.isVisible()) {
                    $rootScope.busyInd.show();
                }

                if (isLocalDev) {
                    $state.go('home');
                } else {
                    submitLoginForm();
                }

            }
        }

        /**
         * handling the response from the challenge Handler
         *
         * @param response - Challenge Handler Response
         */
        function handleSubmit(response) {
            if (isPkmsLogin(response)) {
                location.hash = "#/login";
                $rootScope.busyInd.hide(response);
                $scope.user.userNameError = {};
                $scope.user.passwordError = {};
                $scope.user.errorOccured = {};
                if (isAccountLocked(response)) {
                    $scope.$apply(function () {
                        $scope.user.userNameError.accountLocked = true;
                        $scope.user.passwordError.accountLocked = true;
                        $scope.user.errorOccured.accountLocked = true;
                    });
                } else {
                    $scope.$apply(function () {
                        $scope.user.userNameError.wrongCredentials = true;
                        $scope.user.passwordError.wrongCredentials = true;
                        $scope.user.errorOccured.wrongCredentials = true;
                    });
                }
            } else {
                HeaderAuthRealmChallengeHandler.submitSuccess();
                console.log('loginController: handleSubmit: success');
                setTimeout(function () {
                    checkIfAuthenticated();
                }, 1000);
            }
        }

        function checkIfAuthenticated() {
            console.log('loginController: checkIfAuthenticated');
            //alert("(WL.Client.isUserAuthenticated(\"HeaderAuthRealm\"): " + WL.Client.isUserAuthenticated("HeaderAuthRealm"));
            if (WL.Client.isUserAuthenticated("HeaderAuthRealm") == true) {
                //WL.Client.checkForDirectUpdate();
                getAuthData();
            } else {
                //TODO: Following line for debugging only. Remove before going live.
                //alert ("HeaderAuthRealm = false");
                setTimeout(function () {
                    /*if (location.hash == "#/login") {
                     // If auto update redirects back to login, do nothing.
                     //alert("Recognize redirect back to login. Stop authenticating");
                     }
                     else {*/
                    WL.Client.updateUserInfo();
                    checkIfAuthenticated();
                    /*}*/
                }, 1000);
            }
        }

        /**
         * function to add class for transition
         * @param element
         */
        function addTransition(element) {
            $scope[element + 'HeadingClass'] = 'transitionClass';
        }

        /**
         * function to set the focus on any html form element
         * @param elementClass
         * @param event
         */
        function setFocus(elementClass, event) {
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            addTransition(elementClass);
            $timeout(function () {
                document.getElementsByClassName(elementClass)[0].focus();
            });
        }

        /**
         * function to take away the focus on any html form element
         * @param elementClass
         */
        function setBlur(elementClass) {
            $timeout(function () {
                document.getElementsByClassName(elementClass)[0].blur();
            });
        }

        function validateInput(inputField) {
            if ($scope.user[inputField] == undefined || $scope.user[inputField] == "") {
                $scope.user[inputField + 'Error'].missingInput = true;
            }
        }

        /**
         * function to handle the backbutton
         */
        function handleBackButton() {
            if ($scope.webViewOverlayShown) {
                window.shopWebViewOverlay.close();
                $rootScope.$broadcast("close-passwordResetModal");
                $scope.webViewOverlayShown = false;
            } else {
                $rootScope.$broadcast("handleBack");
            }
        }

        /**
         * function top toggle the webview overlay
         * @Param shown
         */
        function toggleWebViewShown(shown) {
            console.log(shown);
            $scope.webViewOverlayShown = shown;
        }

        /**
         * function to override the back button
         */
        WL.App.overrideBackButton(function (e) {
            e.preventDefault();
            handleBackButton();
        });

        //check network status
        WL.Device.getNetworkInfo(function (networkInfo) {
            if (networkInfo.isNetworkConnected == "true") {
                $scope.networkConnected = true;
            }
            else {
                $scope.networkConnected = false;
            }
        });
        $interval(function () {
            WL.Device.getNetworkInfo(function (networkInfo) {
                if (networkInfo.isNetworkConnected == "true") {
                    $scope.networkConnected = true;
                }
                else {
                    $scope.networkConnected = false;
                }
                $scope.$apply();
            });
        }, 5000);

        activate();
    }
})();
function ShopWebViewOverlayPlugin() {};

ShopWebViewOverlayPlugin.prototype.close = function() {
	cordova.exec(null, null, 'ShopWebViewOverlayPlugin', 'close', []);
};

ShopWebViewOverlayPlugin.prototype.goBack = function() {
	cordova.exec(null, null, 'ShopWebViewOverlayPlugin', 'goBack', []);
};

ShopWebViewOverlayPlugin.prototype.goForward = function() {
	cordova.exec(null, null, 'ShopWebViewOverlayPlugin', 'goForward', []);
};

ShopWebViewOverlayPlugin.prototype.goToPage = function(url) {
	cordova.exec(null, null, 'ShopWebViewOverlayPlugin', 'goToPage', [url]);
};

window.shopWebViewOverlay = new ShopWebViewOverlayPlugin();

/**
*  Loading Overlay Service
*
*  Provides methods for showing and hiding Loading Overlay
*/
(function(){
	angular.module('ccMobile')
	.factory("loadingOverlayService", loadingOverlayService);
	
	function loadingOverlayService(){
		var busyInd = new WL.BusyIndicator ("content", {text: "Loading..."});
		
		var loadingOverlayService = {
				show : show,
				hide : hide
		};
		
		/** Shows Loading Overlay */
		function show(){
			busyInd.show();
		}
		
		/** Hides Loading Overlay */
		function hide(){
			//while(busyInd.isVisible()){
				busyInd.hide();
			//}
		}		
		return loadingOverlayService;
	}
})();
/**
*  Login Service
*
*  Provides Login and Logout methods
*/
(function(){
	'use strict';
	
	loginFactory.$inject = ['$q', 'loginCacheService', 'loadingOverlayService', 'filterPreferences'];
	angular.module('ccMobile')
	.factory('loginFactory',loginFactory);
	
	function loginFactory($q, loginCacheService, loadingOverlayService, filterPreferences){
		var loginFactory={
				login : login,
				logout: logout
		};
		
		/**  Login Method 
		*	 @param userName - userName of the login
		*	 @param password - password of the login
		*/
		function login(userName,password){
			var defered = $q.defer();
			var invocationData = {
			    adapter : 'LoginAdapter',
			    procedure : 'login',
			    parameters : [userName,password]
			};
			var options = {
			    onSuccess : success,
			    onFailure : failure,
			    invocationContext: {}
			};
			
			function success(result){
				if(result.invocationResult.isLoggedInUser == true){
					loginCacheService.saveLoginToken(result.invocationResult.cookie, result.invocationResult.sessionId);
					console.log("login service success");
					loadingOverlayService.hide();
					defered.resolve();
				}else{
					console.log("login service password error");
					loadingOverlayService.hide();
					defered.reject("Incorrect username or password..!");
				}
			}
			
			function failure(){
				console.log("login service unavailable");
				loadingOverlayService.hide();
				defered.reject("Service unavailable");
			}
			loadingOverlayService.show();
			WL.Client.invokeProcedure(invocationData, options);
			return defered.promise;
		}

		/** Logout Method */
		function logout(){
			console.debug("inside logout service method");
			loadingOverlayService.show();
			var defered = $q.defer();
			var invocationData = {
			    adapter : 'LoginAdapter',
			    procedure : 'logout',
			    parameters : ["",""]
			};
			var options = {
				    onSuccess : success,
				    onFailure : failure,
				    invocationContext: {}
				};
			
			function success(result){
					console.log("logout service success");
					loadingOverlayService.hide();
					defered.resolve();
					console.debug("inside the logout");
					WL.Client.logout("HeaderAuthRealm",{
						onSuccess: function(){
							var reqURL = '/../../..'+'/pkmslogout';
						    var options = {};
						    HeaderAuthRealmChallengeHandler.submitLoginForm(reqURL, options, HeaderAuthRealmChallengeHandler.handleChallenge);
						    filterPreferences.filters = angular.copy(['-json.ApplUpdateDT']);
						    filterPreferences.limitTo = 20;
						}, 
						onFailure: function(){
							loadingOverlayService.hide();
						}
					});	
			}
			
			function failure(error){
				console.log("logout service unavailable : error :", error);
				loadingOverlayService.hide();
				defered.reject("Service unavailable");
			}
			
			WL.Client.invokeProcedure(invocationData, options);
			return defered.promise;
				
		}
		return loginFactory;
	}
})();
(function () {
    'use strict';

    userService.$inject = ['$q', 'CONST', '$rootScope'];
    angular.module('ccMobile')
        .factory('userService', userService);
    
    /**
     * @name userService
     * @desc Service for managing user data
     */

    function userService($q, CONST, $rootScope) {

        var service = {};

        //bindables

        service.userData = {
            avnetStatusCode: '',
            id: '',
            isExternalUser: '',
            customerId: '',
            email: '',
            firstName: '',
            lastName: '',
            roles: [],
            permissions: {
                requests: false,
                orders: false,
                invoices: false
            }
        };

        //bindable methods
        service.getUser = getUser;


        function getUser(userId) {
            var deferred = $q.defer();

            var userId = userId ? userId : service.userData.id;

            if(!userId){

                console.log('userService: getUser: no username');

                service.userData.id = localStorage.getItem('LoginId');

                console.log('userService: getUser: set to username from localStorage: ', service.userData.id);
            }

            console.log('userService: getUser: ', service.userData.id);

            var invocationData = {
                adapter: 'UserAdapter',
                procedure: 'getUser',
                parameters: [service.userData.id]
            };

            WL.Client.invokeProcedure(invocationData, {
                onSuccess: loadSuccess,
                onFailure: loadFailure
            });

            function loadSuccess(result) {
                console.log('userService: getUser: success', result);

                prepareUserData(result.responseJSON.userData);

                console.log('userService: getUser: loadSuccess: service.userData.customerId', service.userData);

                deferred.resolve(service.userData);
            }

            function loadFailure(result) {
                console.log('userService: getUser: error', result);
                deferred.reject(result);
            }

            return deferred.promise;

        }


        function prepareUserData(userData) {

            console.log('userService: prepUserData: ', userData);

            service.userData.avnetStatusCode = userData.avnetStatusCode;
            service.userData.id = userData.id;
            service.userData.isExternalUser = userData.isExternalUser;
            service.userData.customerId = userData.customerId;
            service.userData.email = userData.email;
            service.userData.firstName = userData.firstName;
            service.userData.lastName = userData.lastName;
            service.userData.roles = userData.roles;
            $rootScope.IsInternal = service.userData.isExternalUser;

            preparePermissions(service.userData.roles);

            return service.userData;

        }


        function preparePermissions(rolesArray) {

            console.log('userService: preparePermissions: ', rolesArray);

            if(service.userData.isExternalUser){
                for(var a = 0; a < CONST.TOOLS.length; a++){
                    var tool = CONST.TOOLS[a];
                    for (var i = 0; i < rolesArray.length; i++) {
                        var role = rolesArray[i];
                        if (role.name == tool.role) {
                            console.log('userService: preparePermissions: role found: ', role.name);
                            service.userData.permissions[tool.id] = true;
                        }
                    }
                }
            }else{
                console.log('userService: preparePermissions: internal so setting all to true');
                for(var a = 0; a < CONST.TOOLS.length; a++){
                    service.userData.permissions[tool.id] = true;
                }
            }

        }

        return service;
    }
})();
