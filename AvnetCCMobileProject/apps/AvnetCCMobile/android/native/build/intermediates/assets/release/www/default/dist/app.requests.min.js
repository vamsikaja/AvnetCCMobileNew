
/* JavaScript content from dist/app.requests.min.js in folder common */
(function () {

    angular.module('ccMobile.requests', []) ;

})();
var newScope, newFact;
(function(){
	'use strict';
	
	newRequestController.$inject = ['$scope', '$rootScope', 'newRequestFactory', '$state', '$timeout', '$stateParams'];
	angular.module('ccMobile.requests')
		.controller('newRequestController', newRequestController);
	
	/**
	 * main method for the new request
	 */
	function newRequestController($scope, $rootScope, newRequestFactory, $state, $timeout, $stateParams){
		console.log('newRequestController: load');

		$scope.isSubmitButtonClicked=newRequestFactory.isSubmitButtonClicked;
		$scope.disclaimer = {
				isSelected : false
		};
		newScope = $scope;
		newFact = newRequestFactory;

		$scope.productSpecificQuestions = newRequestFactory.productSpecificQuestions || [];
		$scope.notificationListString="Select People to Notify";
		$scope.endUsersListString="Select End User";
		$scope.productsListString="Select Products";
		$scope.requiredResponseString="Select Response";
		$scope.disclaimer = {
				isSelected : false
		};

		$scope.validateRequiredResponse = validateRequiredResponse;
		$scope.validateProductOptions=validateProductOptions;
		$scope.addRequestName=addRequestName;
		$scope.addRequestInstructions=addRequestInstructions;
		$scope.submitRequest=submitRequest;
		$scope.showInstructionsInView=showInstructionsInView;
		$scope.blurElementWithId=blurElementWithId;

		if(newRequestFactory.getRequest() == undefined){
			newRequestFactory.getNewRequest($stateParams.type, $stateParams.requestNo)
			.then(function(request){
				console.log('newRequestController: This is the retrieved request', request);
				$scope.request = request;
				$scope.notificationListCount=0;
				$scope.notificationListString="Select People to Notify";
				$scope.endUsersListString="Select End User";
				$scope.productsListString="Select Products";
				$scope.requiredResponseString="Select Response";
				$scope.disableSubmitButton=true;
				$scope.productSpecificQuestions = newRequestFactory.productSpecificQuestions || [];

				/*if($stateParams.type == "copy"){
					populateProducts();
				}*/

				if($stateParams.type == "copy"){
					console.log('newRequestController: Its a copy request');
					$scope.request.isCopy = true;
				} else { 
					$scope.request.isCopy = false;
				}

				newRequestFactory.setRequest($scope.request);

				validateForm();
			},function(){
				//Error Callback
				WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
				  text : "OK",
				  handler: function(){
				  	$state.go('quotes');	
				  }
				}]);
			});
		}else{
			$scope.request = newRequestFactory.getRequest();
			validateForm();
		}
		
		$rootScope.$on("$stateChangeStart", stateChangeStart);
		function stateChangeStart(event, toState, toParams, fromState, fromParams){
			if($rootScope.menuItems.indexOf(toState.name) != -1 && fromState.name == "newRequest"){
				newRequestFactory.resetNewRequest();
			}
		}
		/**
		 * function to populate the productlist
		 */
		function populateProducts(){
			//populate product index suffix property for repeated properties
			var allProducts = $scope.request.Products;
			var updatedProducts = [];

			var i = 0
			for (; i < allProducts.length; i++) {
				var product = allProducts[i];
				if(!product.productIndexCount){
					product.productIndexCount = 1;
					var j = i + 1;
					var productCountTracker = 1;
					for (; j < allProducts.length; j++) {
						var anotherProduct = allProducts[j];
						if(anotherProduct.EntityTemplateSk == product.EntityTemplateSk){
							//increment the index count
							anotherProduct.productIndexCount = ++productCountTracker;							
						}
					}
				}
				updatedProducts.push(product);
			};

			$scope.request.Products = updatedProducts;
			newRequestFactory.setRequest($scope.request);

			console.log("newRequestController: After populating products", allProducts, updatedProducts, $scope.request);

		}
		

		function showInstructionsInView(){
			$timeout(function() { 
				document.getElementsByClassName('instructions')[0].scrollIntoView(true);
			},1000);
		}
		/**
		 * function to blur a particular element with id
		 * @param id - id of the html element
		 */
		function blurElementWithId(id){
			$timeout(function() { 
				document.getElementById(id).blur();
			});
		}
		
		/**
		 * function to validate the product specific questions
		 */
		function validateProductOptions(){
			var products = newRequestFactory.productSpecificQuestions || [];
			for (var i = products.length - 1; i >= 0; i--) {
				var questions=products[i].questions || [];
				for (var j = questions.length - 1; j >= 0; j--) {
					if((questions[j].answer == undefined || questions[j].answer.length==0) && questions[j].isMandatory)
						return false;
				};
			};
			return true;
		}
		
		/**
		 * function to validate the required response
		 */
		function validateRequiredResponse(){ 
			//check if required response is given
			var givenResponse = newRequestFactory.requiredResponse.filter(function(response){
				return response.id == $scope.request.ResponseTypeSk;
			});
			
			if(givenResponse.length == 0){				
				return false;
			}
			return true;
		}

		/**
		 * function to add the Request Name
		 */
		function addRequestName(){
			newRequestFactory.setRequest($scope.request);
			validateForm();
		}

		/**
		 * function to add the Request Instructions
		 */
		function addRequestInstructions(){
			newRequestFactory.setRequest($scope.request);
			validateForm();
		}


		/**
		 * function to Submit the Request
		 */
		function submitRequest(requestName){
			$scope.isSubmitButtonClicked=true;
			newRequestFactory.isSubmitButtonClicked=true;
			var errorOccured;
			/*if($scope.request.notificationEmails==undefined || $scope.request.notificationEmails.length==0 )
			{
				console.log('notificationError found');
				$scope.notificationError=true;
				$scope.disableSubmitButton=true;
			}*/

			if(newRequestFactory.isEndUserNotRequired){
				if(hasUS33SalesOrgPartner($scope.request.Partners)){
					if(($scope.request.businessSector==undefined) || ($scope.request.businessSector=="")){
						$scope.endUsersError=true;
						$scope.disableSubmitButton=true;
					}
				}
			}
			else{
				if($scope.request.addedEndUsers==undefined || $scope.request.addedEndUsers.length==0){
					$scope.endUsersError=true;
					$scope.disableSubmitButton=true;
				}
			}

			if($scope.request.Products==undefined || $scope.request.Products.length==0){
				$scope.productsError=true;
				$scope.disableSubmitButton=true;
			}

			if(!validateProductOptions()){
				$scope.productOptionsError=true;
				$scope.disableSubmitButton=true;
			}

			if(!validateRequiredResponse()){
				$scope.requiredResponseError=true;
				$scope.disableSubmitButton=true;
			}

			if($scope.request.RequestName==undefined || $scope.request.RequestName==""){
				$scope.requestNameError=true;
				$scope.disableSubmitButton=true;
			}

			/*console.log('$scope.request.requestInstructions :'+$scope.request.requestInstructions);
			if($scope.request.requestInstructions!=undefined && $scope.request.requestInstructions!=""){
				if(!testAlphaNumeric($scope.request.requestInstructions)){
					console.log('addRequestInstructionsError found');
					$scope.requestInstructionsError=true;
					$scope.disableSubmitButton=true;
				}
			}*/

			if(!$scope.disableSubmitButton){
				newRequestFactory.getDisclaimer()
				.then(function(results){
					newRequestFactory.disclaimers = results;
					if(results.length > 0){
						$state.go('^.disclaimer');
					}else{
						if(newRequestFactory.isEndUserNotRequired){
							var request = newRequestFactory.getRequest();
							request.addedEndUsers.length = 0;
							newRequestFactory.setRequest(request);
						}
						newRequestFactory.submitRequest()
						.then(function(){
							newRequestFactory.setRequest(undefined);
							newRequestFactory.isSubmitButtonClicked=false;
							newRequestFactory.questionsSaveClicked=false;
							newRequestFactory.temporaryNotificationEmails=[];
							newRequestFactory.temporarySelectedContacts=[];	
							$state.go('^.submissionSuccessful');
						}, function(){
							WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
							  text : "OK",
							  handler: function(){
							  	$state.go('^.newRequest');
							  }
							}]);						
						});
					}
				},function(){
					WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
					  text : "OK"
					}]);
				});
			}
		}

		/**
		 * function to validate the new Request form
		 */
		function validateForm(){
			$scope.disableSubmitButton=false;

			if(!(($scope.request.notificationEmails==undefined) || ($scope.request.notificationEmails.length==0))){
				
				$scope.correctlyFilledNotificationsList=true;
				var selectedAddedEmails=$scope.request.notificationEmails.filter(function(e){ return !angular.isObject(e) }).map(function(e){ return e})
				$scope.notificationListCount=selectedAddedEmails.length;
				$scope.notificationListString=selectedAddedEmails.join(', ');

				var selectedReceivedEmails=$scope.request.notificationEmails.filter(function(e){ return angular.isObject(e) }).map(function(e){ return e.EmailAddress});
				if(selectedReceivedEmails.length!=0 && selectedAddedEmails.length!=0)
					$scope.notificationListString=$scope.notificationListString+', ';
				$scope.notificationListCount=$scope.notificationListCount+selectedReceivedEmails.length;
				$scope.notificationListString=$scope.notificationListString+selectedReceivedEmails.join(', ');
			}
			else{
				$scope.notificationListCount=0;
				$scope.notificationListString="Select People to Notify";
				/*$scope.disableSubmitButton=true;
				if($scope.isSubmitButtonClicked){
					$scope.notificationError=true;
				}*/
			}

			if(newRequestFactory.isEndUserNotRequired){
				$scope.endUsersListString="No End User";
				if(hasUS33SalesOrgPartner($scope.request.Partners)){
					if(!(($scope.request.businessSector==undefined) || ($scope.request.businessSector==""))){
						$scope.correctlyFilledEndUsers=true;
						//$scope.endUsersListString=$scope.request.businessSector;
					}
					else{
						//$scope.endUsersListString="No End User for this Request";
						$scope.disableSubmitButton=true;
						if($scope.isSubmitButtonClicked){
							$scope.endUsersError=true;
						}
					}
				}
				else{
					$scope.correctlyFilledEndUsers=true;
				}
			}
			else{
				if(!(($scope.request.addedEndUsers==undefined) || ($scope.request.addedEndUsers.length==0))){
					$scope.correctlyFilledEndUsers=true;
					$scope.endUsersListString=$scope.request.addedEndUsers.map(function(item){return item.PartnerName;}).join(', ');
				}
				else{
					$scope.endUsersListString="Select End User";
					$scope.disableSubmitButton=true;
					if($scope.isSubmitButtonClicked){
						$scope.endUsersError=true;
					}
				}
			}

			if(!(($scope.request.Products == undefined) || ($scope.request.Products.length==0))){
				$scope.correctlyFilledProducts=true;
				$scope.productsListString=$scope.request.Products.map(function(item){
					if(item.productIndexCount>1)
						return item.EntityTemplateName+" "+item.productIndexCount;
					else
						return item.EntityTemplateName;
				}).join(', ');
			}
			else{
				$scope.productsListString="Select Products";
				$scope.disableSubmitButton=true;
				if($scope.isSubmitButtonClicked){
					$scope.productsError=true;
				}
			}

			(function(){
				var products = newRequestFactory.productSpecificQuestions || [];
				var prodCount=0;
				for (var i = products.length - 1; i >= 0; i--) {
					var questions=products[i].questions || [];
					var j = questions.length - 1
					for (; j >= 0; j--) {
						if((questions[j].answer == undefined || questions[j].answer == null || questions[j].answer.length==0) && questions[j].isMandatory){
							console.log('no answer Specified');
							break;
						}
					};
					console.log(j);
					if(j!=-1){
						prodCount=prodCount+1;
					}
					console.log('prodCount :'+prodCount);
				};
				if(prodCount >1){
					$scope.productOptionsString=prodCount+' Products Require More Info';
				}
				else if(prodCount == 1){
					$scope.productOptionsString=prodCount+' Product Requires More Info';
				}
				else{
					if(products.length>1)
						$scope.productOptionsString=products.length+' Products Ready';
					else
						$scope.productOptionsString=products.length+' Product Ready';
				}
			})();

			if(validateProductOptions()){
				$scope.correctlyFilledProductOptions=true;
			}
			else{
				$scope.disableSubmitButton=true;
				if($scope.isSubmitButtonClicked){
					$scope.productOptionsError=true;
				}
			}

			if(validateRequiredResponse()){
				$scope.correctlyFilledRequiredResponse=true;
				$scope.requiredResponseString=newRequestFactory.requiredResponse.filter(function(response){return response.id == $scope.request.ResponseTypeSk;}).map(function(e){return e.response})[0];
			}
			else{
				$scope.disableSubmitButton=true;
				$scope.requiredResponseString="Select Response";
				if($scope.isSubmitButtonClicked){
					$scope.requiredResponseError=true;
				}
			}

			if($scope.request.RequestName==undefined || $scope.request.RequestName==""){
				if($scope.isSubmitButtonClicked){
					$scope.requestNameError=true;
				}
				$scope.disableSubmitButton=true;
			}
			else{
				$scope.requestNameError=false;
			}

			/*console.log('$scope.request.requestInstructions :'+$scope.request.requestInstructions);
			if($scope.request.requestInstructions==undefined || $scope.request.requestInstructions==""){
				$scope.requestInstructionsError=false;
			}
			else{
				if(!testAlphaNumeric($scope.request.requestInstructions)){
					console.log('addRequestInstructionsError found');
					$scope.disableSubmitButton=true;
					if($scope.isSubmitButtonClicked){
						$scope.requestInstructionsError=true;
					}
				}
			}*/
			return $scope.disableSubmitButton;
		}

		/**
		 * function to check the sales organization code
		 * @param partners - list of partners
		 */
		function hasUS33SalesOrgPartner(partners){
			for(var i=0;i<(partners || []).length;i++){
				if(partners[i].SalesOrganizations.map(function(item){return item.SalesOrgCode;}).indexOf('US33') != -1){
					return true;
				}
			}
			return false;
		}

		/**
		 * function to validate the requestname.
		 * @param requestName - name of the request
		 */
		function testAlphaNumeric(requestName){
			var regex = new RegExp("^[a-zA-Z0-9\\s]+$");
			if(regex.test(requestName)){
		    	return true;
		    }
		    return false;
		}
	}
})();
var newRequestFact;
(function(){
	'use strict';
	
	quoteDetailController.$inject = ['$scope', '$stateParams', 'quoteDetailFactory', 'quoteDetailCacheService', '$rootScope', 'loginCacheService', 'loadingOverlayService', '$timeout', '$state', 'newRequestFactory'];
	angular.module('ccMobile.requests')
		.controller('quoteDetailController', quoteDetailController);
	/**
	 * quotesDetail controller main
	 */
	function quoteDetailController($scope, $stateParams,quoteDetailFactory,quoteDetailCacheService,$rootScope,loginCacheService, loadingOverlayService,$timeout,$state, newRequestFactory){
		newRequestFact=newRequestFactory;
		$stateParams.RequestRevisionSK=angular.copy(localStorage.getItem('RequestRevisionSK'));
		$scope.tabContent='details';
		$scope.showEndUserInfo=true;
		$scope.showProductInfo=true;
		$scope.changeTabContentTo=changeTabContentTo;
		$scope.transformLeft='';
		$scope.title = 'Quote Request';
		
		$scope.showFileShare=showFileShare;
		$scope.removeFileShare=removeFileShare;
		$scope.revealedFileIdIndex = '-1';
		
		$scope.toggleQuoteAccordion = toggleQuoteAccordion;
		$scope.revealedQuoteAccordionIndex = '-1';
		$scope.shareFile = shareFile;	
		$scope.getNotesHeading = getNotesHeading;
		$scope.getNotesComments = getNotesComments;
		$scope.showNotesDescription=showNotesDescription;
		$scope.showQuotesDescription=showQuotesDescription;
		$scope.tabIndex = {index:4};
		$scope.notesIndex = {index:1};
		$scope.handleBackButton = handleBackButton;
		$scope.hideFilesHelpScreen=hideFilesHelpScreen;
		$scope.hidedetailsHelpScreen=hidedetailsHelpScreen;
		$scope.hideQuoteNotesDescriptionHelpScreen=hideQuoteNotesDescriptionHelpScreen;
		$scope.showEditRequestName = showEditRequestName;
		$scope.showAddNote = showAddNote;
		$scope.addNewNote = addNewNote;
		$scope.updateRequestName = updateRequestName;
		$scope.cancelEditRequestName = cancelEditRequestName;
		$scope.cancelAddNote = cancelAddNote;
		$scope.showEditEndUser=showEditEndUser;
		$scope.updateEditEndUser = updateEditEndUser;
		$scope.cancelEditEndUser = cancelEditEndUser;
		$scope.redirectToSelectEndUserScreen=redirectToSelectEndUserScreen;
		$scope.redirectToRequestNotification = redirectToRequestNotification;
		$scope.hideModal=hideModal;
		$scope.goToSelectProductToRevise = goToSelectProductToRevise;
		$scope.getCustomProductName=getCustomProductName;
		
		$rootScope.showDetailsHeaderButton=true;
		$rootScope.toggleRequestActionButtons=toggleRequestActionButtons;
		$scope.goToRequestAction=goToRequestAction;
		$scope.closeRequestActionButtons=closeRequestActionButtons;
		$scope.hideHeaderButton=hideHeaderButton;
		$scope.blurElementWithId=blurElementWithId;
		
		var tempIsRequestRevisableFlag;
		var endUserChangedSuccessfully;
		var notedAddedSuccessfully;
		var quoteDetailsHelpScreenShownLocal;
		var quoteNoteDetailsHelpScreenShownLocal;
		var quoteFilesHelpScreenShownLocal;

		$scope.editValues = {
				"editRequestNameValue" : ""
		}
		
		$scope.newNote = {
			"noteValue": "",
			"recipients": []
		}
		
		/**
		 * function to navigate to revise request page from the Quote Details page.
		 */
		function goToSelectProductToRevise(){
			newRequestFactory.selectedRequestQuote = $scope.quoteDetail;

			if(newRequestFactory.selectedRequestQuote.products.length > 1){
				$state.go('selectProductToRevise',{'RequestRevisionSK':$stateParams.RequestRevisionSK});	
			} else {
				// if there is only one product then just skip the select products screen
				newRequestFactory.selectedReviseProduct = newRequestFactory.selectedRequestQuote.products[0];
				$state.go('selectItemtoRevise',{'RequestRevisionSK':$stateParams.RequestRevisionSK});
			}			
		}
		
		$scope.$on('online',function(){
			if($scope.quoteDetail == undefined){
				loadQuoteDetail();
			}
		});

		$scope.$on('offline',function(){
			
		});
		
		if(quoteDetailFactory.quoteDetailEndUserClicked){
			$scope.quoteDetail=quoteDetailFactory.quoteDetailData;
			angular.element(document).ready(function(){
				$scope.showEditEndUser();
	    	});
		}
		else if(quoteDetailFactory.addNoteSendNotificationClicked){
			$scope.quoteDetail=quoteDetailFactory.quoteDetailData;
			angular.element(document).ready(function(){
				$scope.showAddNote();
	    	});
		}
		else{
			$rootScope.showDetailsHeaderButton=true;
			loadQuoteDetail();
		}	

		/**
		 * function to load the quote.
		 * @param result - result from the service
		 */
		function loadLocalQuote(result){
			console.log('in loadLocalQuote success method');
			$scope.quoteDetail = result;
			//sorting notes
			$scope.quoteDetail.notes=$scope.quoteDetail.notes.sort(function(a,b){
				if(a.CreateDate > b.CreateDate)
					return -1;
				else if(a.CreateDate == b.CreateDate)
					return 0;
				else
					return 1;
			});
			$scope.title = $scope.quoteDetail.requestName;
			$scope.editValues.editRequestNameValue = $scope.quoteDetail.requestName || '';
			if(localStorage.getItem(localStorage.getItem('LoginId')+'hideRequestDetailsHelpScreen') != "true"){
				localStorage.setItem(localStorage.getItem('LoginId')+'hideRequestDetailsHelpScreen',"true");
				angular.element(document).ready(function (){
					quoteDetailsHelpScreenShownLocal=true;
			        $scope.revealedrequestIdIndex = 0;
			        $rootScope.quoteDetailsHelpScreenShown=true;
			        tempIsRequestRevisableFlag=$scope.quoteDetail.IsRequestRevisable;
			        $scope.quoteDetail.IsRequestRevisable=true;
			        $scope.requestActionButtonsShown=true;
					$rootScope.$broadcast("toggle-quoteDetailsHelpModal");
			    });
			}
			addProductIndexCount($scope.quoteDetail.products);
			function addProductIndexCount(products){
				for(var i=0;i<products.length;i++){
					products[i].productIndexCount=products.slice(0,i).filter(function(e){return e.EntityTemplateSk == products[i].EntityTemplateSk}).length +1;
					
				}
			}
			if(endUserChangedSuccessfully){
				$scope.showSuccessMessage=true;
    			setTimeout(function(){
    				endUserChangedSuccessfully=false;
    				$scope.showSuccessMessage=false;
    			},3000);
			}
			else if(notedAddedSuccessfully){
				$scope.showSuccessMessage=true;
    			setTimeout(function(){
    					notedAddedSuccessfully=false;
		    			$scope.showSuccessMessage=false;
	    		},3000);
			}
			/*quoteDetailCacheService.getQuoteDetail($stateParams.RequestRevisionSK)
			.then(function(result){
						
			}, function(error){
				console.log("quoteDetailController: Error while retrieving quotes details", error);
				WL.SimpleDialog.show("Service Unavailable", "Could not fetch details. Please try again later.", [{ 
						text : "OK", 
						handler : function() {handleBackButton();}}]);
			});*/
		}
		
		/**
		 * wrapper function to load the quote details
		 *
		 */
		function loadQuoteDetail(){
			quoteDetailFactory.loadQuoteDetailData($stateParams.RequestRevisionSK)
			.then(function(data){
				loadLocalQuote(data);
			},function(message){
				if(message == "Service unavailable"){
					//loadLocalQuote(); //disabling cache
					//$rootScope.logout();
					WL.SimpleDialog.show("Service Unavailable", "Could not fetch details. Please try again later.", [{ text : "OK", handler : function() {}}]);
				}else if(message == "no network"){
					WL.SimpleDialog.show("Check Network Connection", "Could not fetch details. Please try again later.", [{ text : "OK", handler : function() {}}]);
				}else{
					WL.SimpleDialog.show("Permission Denied", message, [{ text : "OK", handler : function() { $state.go('quotes');}}]);
				}
			});
		}


		/**
		 * function to get the product name using a particular logic
		 * @param product - product data 
		 */
		function getCustomProductName(product){
			if(product.ProductName != product.SupplierName + " - " + product.EntityTemplateName)
				return product.ProductName;

			var productName = product.EntityTemplateName;
			
			if(product.productIndexCount > 0){
				if(product.productIndexCount != 1) {
					productName = productName + ' ' + product.productIndexCount;
				}
			} 

			return productName;			
		}

		/**
		 * function to change the tab content
		 * @param index - tab index
		 */
		function changeTabContentTo(index){
			$scope.closeRequestActionButtons();
			$timeout(function(){
				$scope.tabIndex.index = index;
			},0);
			if(index == 3){
				if((localStorage.getItem(localStorage.getItem('LoginId')+'hideRequestFilesHelpScreen') != "true" ) && !($scope.quoteDetail==undefined || $scope.quoteDetail.entityFiles.length==0)){
					localStorage.setItem(localStorage.getItem('LoginId')+'hideRequestFilesHelpScreen',"true");
					$scope.revealedFileIdIndex=0;
					quoteFilesHelpScreenShownLocal=true;
					$rootScope.$broadcast("toggle-quoteFilesHelpModal");
				}
			}
		}

		/**
		 * function to show file share
		 * @param index
		 */
		function showFileShare(index){
			$scope.revealedFileIdIndex = index;
		}

		/**
		 * function to remove file share
		 * @param index
		 */
		function removeFileShare(index){
			if(index == $scope.revealedFileIdIndex){
				$scope.revealedFileIdIndex= "-1";
			}	
		}
		/**
		 * function to display the edit request name option
		 */
		function showEditRequestName() {
			$rootScope.showDetailsHeaderButton=false;
			$scope.requestActionButtonsShown=false;
			$scope.editValues.editRequestNameValue = $scope.quoteDetail.requestName;
			$rootScope.$broadcast("toggle-editRequestName");
		}
		
		/**
		 * function to cancel the edit request name
		 */
		function cancelEditRequestName() {
			$rootScope.showDetailsHeaderButton=true;
			$rootScope.$broadcast("toggle-editRequestName");
		}

		/**
		 * function to update the request name
		 */
		function updateRequestName(){
			$rootScope.showDetailsHeaderButton=true;
			//alert("requestSk: " + $stateParams.RequestRevisionSK + " newRequestName: " + $scope.editValues.editRequestNameValue);
			quoteDetailFactory.editRequestName($stateParams.RequestRevisionSK, $scope.editValues.editRequestNameValue)
			.then(function(response) {
				//alert("success. close modal");
				if(response.invocationResult.data.ReturnResult.ResultMessage=="Completed Successfully" || response.invocationResult.data.ReturnResult.ResultMessage == "An error occurred retrieving the Quote List from Q2O"){
					$scope.quoteDetail.requestName = $scope.editValues.editRequestNameValue;
					$scope.successMessage="Request Name Changed Successfully";
					$scope.showSuccessMessage=true;
		    		setTimeout(function(){
		    			$scope.showSuccessMessage=false;
		    		},3000);
					$rootScope.$broadcast("toggle-editRequestName");
				}
				else{
					$scope.requestsErrorMessage="Unable to edit request name. Please check your connection and try again";
					WL.SimpleDialog.show("Service Unavailable", $scope.requestsErrorMessage, [{ text : "OK", handler : function() {cancelEditRequestName();}}]);
				}
			},function(error){
				$scope.requestsErrorMessage="Unable to edit request name. Please check your connection and try again";
				WL.SimpleDialog.show("Service Unavailable", $scope.requestsErrorMessage, [{ text : "OK", handler : function() {cancelEditRequestName();}}]);
				//logout();
			});
		}
		
		/**
		 * function to show the add note functionality
		 */
		function showAddNote() {
			quoteDetailFactory.quoteDetailData=angular.copy($scope.quoteDetail);
			$rootScope.showDetailsHeaderButton=false;
			$scope.requestActionButtonsShown=false;
			$rootScope.$broadcast("toggle-addNoteModalView");
			if(newRequestFactory.getRequest() == undefined){
				newRequestFactory.getNewRequest('new')
				.then(function(request){
					$scope.request = request;
					populateNotificationContactsStringAndCount();
				},function(){
					WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
					  text : "OK",
					  handler: function(){
					  	$scope.cancelAddNote();	
					  }
					}]);
				});
			}else{
				$scope.request = newRequestFactory.getRequest();
				populateNotificationContactsStringAndCount();
				if(quoteDetailFactory.addNoteSendNotificationClicked){
					$scope.newNote.noteValue=quoteDetailFactory.note;
					$timeout(function(){
						$scope.changeTabContentTo(2);
					},300);
				}
			}
			quoteDetailFactory.addNoteSendNotificationClicked=true;
			
			/**
			 * function to populate the contacts
			 */
			function populateNotificationContactsStringAndCount(){
				if(!(($scope.request.notificationEmails==undefined) || ($scope.request.notificationEmails.length==0))){
					$scope.correctlyFilledNotificationsList=true;
					var selectedAddedEmails=$scope.request.notificationEmails.filter(function(e){ return !angular.isObject(e) }).map(function(e){ return e})
					$scope.notificationListCount=selectedAddedEmails.length;
					$scope.notificationListString=selectedAddedEmails.join(', ');

					var selectedReceivedEmails=$scope.request.notificationEmails.filter(function(e){ return angular.isObject(e) }).map(function(e){ return e.EmailAddress});
					if(selectedReceivedEmails.length!=0 && selectedAddedEmails.length!=0)
						$scope.notificationListString=$scope.notificationListString+', ';
					$scope.notificationListCount=$scope.notificationListCount+selectedReceivedEmails.length;
					$scope.notificationListString=$scope.notificationListString+selectedReceivedEmails.join(', ');
				}
				else{
					$scope.notificationListCount=0;
					$scope.notificationListString="Please select notifications";
				}
			}
		}
		
		/**
		 * function to cancel add note
		 */
		function cancelAddNote(){
			$rootScope.showDetailsHeaderButton=true;
			$rootScope.$broadcast("toggle-addNoteModalView");	
			quoteDetailFactory.addNoteSendNotificationClicked=false;
			$scope.newNote.noteValue="";
			$scope.request.notificationEmails=[];
			newRequestFactory.temporaryNotificationEmails=[];
			newRequestFactory.temporarySelectedContacts=[];

			newRequestFactory.setRequest(angular.copy($scope.request));
		}
		
		/**
		 * function to add new note
		 */
		function addNewNote() {
			$rootScope.showDetailsHeaderButton=true;
			
			var adHocRecipients = ($scope.request.notificationEmails || []).filter(function(contact){
				return !angular.isObject(contact);
			});
			var recipients = ($scope.request.notificationEmails || []).filter(function(contact){
				return angular.isObject(contact);
			}).map(function(contact) { return contact.EmailAddress });
			
			quoteDetailFactory.addNote($stateParams.RequestRevisionSK, $scope.newNote.noteValue, recipients, adHocRecipients)
			.then(function(response){
				if(response.invocationResult.data.ReturnResult.ResultMessage=="Completed Successfully" || response.invocationResult.data.ReturnResult.ResultMessage == "An error occurred retrieving the Quote List from Q2O" ){
					$scope.newNote.noteValue="";
					$scope.successMessage="Note Added Successfully";
					notedAddedSuccessfully=true;
					$rootScope.$broadcast("toggle-addNoteModalView");
					
					quoteDetailFactory.addNoteSendNotificationClicked=false;
					$scope.request.notificationEmails=[];
					newRequestFactory.temporaryNotificationEmails=[];
					newRequestFactory.temporarySelectedContacts=[];
					newRequestFactory.setRequest(angular.copy($scope.request));
					
					loadQuoteDetail();
				}
				else{
					$scope.requestsErrorMessage="Unable to create new note. Please check your connection and try again";
					WL.SimpleDialog.show("Service Unavailable", $scope.requestsErrorMessage, [{ text : "OK", handler : function() {quoteDetailFactory.addNoteSendNotificationClicked=false;$scope.cancelAddNote();}}]);
				}
			},function(error){
				$scope.requestsErrorMessage="Unable to create new note. Please check your connection and try again";
				WL.SimpleDialog.show("Service Unavailable", $scope.requestsErrorMessage, [{ text : "OK", handler : function() {quoteDetailFactory.addNoteSendNotificationClicked=false;$scope.cancelAddNote();}}]);
			});
		}
		
		/**
		 * function to display edit end user option
		 */
		function showEditEndUser(){
			quoteDetailFactory.quoteDetailData=angular.copy($scope.quoteDetail);
			$scope.hideHeaderButton();
			$scope.requestActionButtonsShown=false;
			$scope.quoteDetailEndUserClicked=angular.copy(quoteDetailFactory.quoteDetailEndUserClicked);
			$rootScope.$broadcast("toggle-editEndUser");
			if(newRequestFactory.getRequest() == undefined){
				newRequestFactory.getNewRequest('new')
				.then(function(request){
					$scope.request = request;
					if(!$scope.quoteDetailEndUserClicked && $scope.quoteDetail.partnerDetails!=undefined){
						var requestEndUser=$scope.request.RecentEndUsers.filter(function(endUser){
							return endUser.PartnerId==$scope.quoteDetail.partnerDetails.endUserAccountId;
						})[0];
						$scope.request.addedEndUsers=[requestEndUser];
						newRequestFactory.setRequest(angular.copy($scope.request));
					}
					quoteDetailFactory.quoteDetailEndUserClicked=true;
				},function(){
					//Error Callback
					console.log("newRequestController: error retrieving newRequest");
					WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
					  text : "OK",
					  handler: function(){
					  	/*$state.go('quotes');*/
					  	$scope.cancelEditEndUser();
					  	//quoteDetailFactory.quoteDetailEndUserClicked=false;	
					  }
					}]);
				});
			}else{
				$scope.request = newRequestFactory.getRequest();
				if(!$scope.quoteDetailEndUserClicked && $scope.quoteDetail.partnerDetails!=undefined){
					var requestEndUser=$scope.request.RecentEndUsers.filter(function(endUser){
						return endUser.PartnerId==$scope.quoteDetail.partnerDetails.endUserAccountId;
					})[0];
					$scope.request.addedEndUsers=[requestEndUser];
					newRequestFactory.setRequest(angular.copy($scope.request));
				}
				quoteDetailFactory.quoteDetailEndUserClicked=true;
			}
		}

		function cancelEditEndUser(){
			$rootScope.showDetailsHeaderButton=true;
			quoteDetailFactory.quoteDetailEndUserClicked=false;
			$scope.selectEndUserError=false;
			$scope.request.addedEndUsers=[];
			newRequestFactory.setRequest(angular.copy($scope.request));
			$rootScope.$broadcast("toggle-editEndUser");
		}

		/**
		 * function to update the end user
		 */
		function updateEditEndUser(){
			if($scope.request.addedEndUsers.length>0){
				$rootScope.showDetailsHeaderButton=true;
				var requestJson=angular.copy($scope.request.addedEndUsers[0]);
				requestJson.CreateUserId=localStorage.getItem('LoginId');
				requestJson.RequestSk=parseInt($stateParams.RequestRevisionSK);
				/*requestJson.EntityType="Partner";*/
				requestJson.PartnerRoleTypeCode="SAPEUO";
				quoteDetailFactory.editEndUser(requestJson,$stateParams.RequestRevisionSK)
				.then(function(response){
					if(response.invocationResult.data.ReturnResult.ResultMessage=="Completed Successfully" || response.invocationResult.data.ReturnResult.ResultMessage == "An error occurred retrieving the Quote List from Q2O" || response.invocationResult.data.ReturnResult.ResultMessage == "An error occurred Updating the End User in R2O"){
						endUserChangedSuccessfully=true;
						quoteDetailFactory.quoteDetailEndUserClicked=false;
						$rootScope.$broadcast("toggle-editEndUser");
						$scope.successMessage="End User Changed Successfully";
						
						loadQuoteDetail();
					}
					else{
						$scope.requestsErrorMessage="Unable to edit End User. Please check your connection and try again";
						WL.SimpleDialog.show("Service Unavailable", $scope.requestsErrorMessage, [{ text : "OK", handler : function() {quoteDetailFactory.quoteDetailEndUserClicked=false;$scope.cancelEditEndUser();}}]);
					}
				},function(error){
					$scope.requestsErrorMessage="Unable to edit End User. Please check your connection and try again";
					WL.SimpleDialog.show("Service Unavailable", $scope.requestsErrorMessage, [{ text : "OK", handler : function() {quoteDetailFactory.quoteDetailEndUserClicked=false;$scope.cancelEditEndUser();}}]);
					//logout();
				});
			}
			else{
				$scope.selectEndUserError=true;
			}
		}

		/**
		 * function to redirect to select end user screen
		 */
		function redirectToSelectEndUserScreen(){
			$rootScope.$broadcast("toggle-editEndUser");
			$scope.hideHeaderButton();
			$rootScope.goToState('selectEndUser');
		}
		
		/**
		 * function to redirect to request notification screen
		 */
		function redirectToRequestNotification(){
			quoteDetailFactory.note=$scope.newNote.noteValue;
			$rootScope.$broadcast("toggle-addNoteModalView");
			$rootScope.goToState('requestNotification');
		}
		
		/**
		 * function to toggle Quote Accordion
		 * @param - index
		 */
		function toggleQuoteAccordion(index){
			if(index == $scope.revealedQuoteAccordionIndex){
				$scope.revealedQuoteAccordionIndex= "-1";
			}else{
				$scope.revealedQuoteAccordionIndex = index;
			}			
		}
		
		/**
		 * function to invoke the native share functionality plugin
		 * @param attachmentId - attachment id for the file
		 * @param extension - file extension
		 * @param filename - name of the file
		 * @param action - action to be performed
		 * @param requestName - Name of the Quote Request
		 */
		function shareFile(attachmentId, extension, filename, action, requestName){
			$timeout(function(){
				$scope.revealedFileIdIndex= "-1";
			},0);		
			loadingOverlayService.show();
			var fileBaseUrl=localStorage.getItem("fileBaseUrl");
			var url = fileBaseUrl + attachmentId;
			
			var credentials = loginCacheService.getLoginToken();
			console.log("cookie ::: " + credentials.cookie);
			var ext = extension.split(".");
			var bigId=localStorage.getItem('bigIpCookie');
			var localPid=localStorage.getItem('pdId');
			$timeout(function(){
				r2oShare.shareItem(function(){
					loadingOverlayService.hide();
				},function(){
					loadingOverlayService.hide();
				},{
					"action" : action,
					"url" : url,
					"filename" : filename,
					"Cookie" : localPid+','+bigId,
					"R2oSessionId" : credentials.sessionId,
					"requestName" : requestName,
					"extension" : ext[ext.length-1]
				});
			},0);
		}

		/**
		 * function to return the notes heading
		 * @param note - note response
		 */
		function getNotesHeading(note){

			if(note.NoteType =='Product Note') {
				return note.EntityName;
			} /*else if(note.EntityType == "RequestNote"){
				return getNotesComments(note);
			}*/
			else{
				return getNotesComments(note);
			}

		}

		/**
		 * function to return the notes comments
		 * @param note - note response
		 */
		function getNotesComments(note){
			var tempNotes = note.NoteText.split("Comments:\n");
			if(tempNotes && tempNotes.length == 2){
				return tempNotes[1];
			} else { 
				return note.NoteText;
			}
		}

		/**
		 * function to return the notes description
		 * @param noteindex
		 */
		function showNotesDescription(noteIndex){
			var index = noteIndex+1;
			$scope.notesIndex = {index:index};
			$scope.notesDescriptionShown=true;
			if(localStorage.getItem(localStorage.getItem('LoginId')+'hideRequestNotesDescriptionHelpScreen') != "true" ){
				localStorage.setItem(localStorage.getItem('LoginId')+'hideRequestNotesDescriptionHelpScreen',"true");
				$scope.revealedFileIdIndex=1;
				quoteNoteDetailsHelpScreenShownLocal=true;
				$rootScope.$broadcast("toggle-quoteNotesDescriptionHelpModal");
			}
		}
		
		/**
		 * function to hide the notes description
		 */
		function hideNotesDescription(){
			$scope.notesDescriptionShown=undefined;
		}
		
		
		/**
		 * function to show the notes description
		 * @param quoteNumber
		 * @param quoteRevisionNumber
		 */
		function showQuotesDescription(quoteNumber, quoteRevisionNumber){
			$scope.quotesDescriptionShown=true;
			quoteDetailFactory.getQuoteLineData(quoteNumber, quoteRevisionNumber)
			.then(function(lineItems){
				$scope.quoteDetail.lineItems = lineItems;
			},function(message){
				$scope.quoteDetail.lineItems.length = 0;
				WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
					text : "OK"
				}]);
			});			
		}

		/**
		 * function to toggle request action buttons
		 */
		function toggleRequestActionButtons(){
			if(!quoteDetailsHelpScreenShownLocal && !quoteNoteDetailsHelpScreenShownLocal && !quoteFilesHelpScreenShownLocal)
				$scope.requestActionButtonsShown=!$scope.requestActionButtonsShown;
		}
		
		function closeRequestActionButtons(){
			$scope.requestActionButtonsShown=false;
		}

		/**
		 * function to navigate to revise or copy page
		 */
		function goToRequestAction(actionName){
			$scope.closeRequestActionButtons();
			$scope.hideHeaderButton();
			switch(actionName) {
			    case 'copy':
			    	newRequestFactory.setRequest(undefined);
			        $rootScope.goToState('newRequest',{type:'copy', requestNo :$stateParams.RequestRevisionSK});
			        break;
			    case 'revise':
			        $scope.goToSelectProductToRevise();
			        break;
			}

		}

		function hideHeaderButton(){
			$rootScope.showDetailsHeaderButton=false;
		}

		function hideQuotesDescription(){
			$scope.quotesDescriptionShown=undefined;
		}

		/**
		 * function to hide files help screen
		 */
		function hideFilesHelpScreen(){
			quoteFilesHelpScreenShownLocal=false;
			$scope.revealedFileIdIndex=-1;
			$rootScope.$broadcast("toggle-quoteFilesHelpModal");
		}
		
		/**
		 * function to quote details files help screen
		 */
		function hidedetailsHelpScreen(){
			$rootScope.quoteDetailsHelpScreenShown=false;
			quoteDetailsHelpScreenShownLocal=false;
			$scope.quoteDetail.IsRequestRevisable=tempIsRequestRevisableFlag;
			$scope.requestActionButtonsShown=false;
			$rootScope.$broadcast("toggle-quoteDetailsHelpModal");	
		}

		/**
		 * function to hide quote notes help screen
		 */
		function hideQuoteNotesDescriptionHelpScreen(){
			quoteNoteDetailsHelpScreenShownLocal=false;
			$rootScope.$broadcast("toggle-quoteNotesDescriptionHelpModal");
		}

		/**
		 * function to hide modal
		 * @param modal object
		 */
		function hideModal(modal){
			$rootScope.$broadcast("close-"+modal);
		}

		function blurElementWithId(id){
			$timeout(function() { 
				document.getElementById(id).blur();
			});
		}
		/**
		 * function to handle the back button
		 */
		function handleBackButton(){
			$scope.closeRequestActionButtons();
			newRequestFactory.resetNewRequest();
			quoteDetailFactory.quoteDetailData=undefined;
			quoteDetailFactory.quoteDetailEndUserClicked=undefined;
			quoteDetailFactory.addNoteSendNotificationClicked=undefined;
			localStorage.setItem('RequestRevisionSK',null);
			switch($scope.tabIndex.index){
				case 1:
					if($scope.quotesDescriptionShown){
						hideQuotesDescription();
					}else{
						broadCastHandleBack();
					}
					break;
				case 2:
					if($scope.notesDescriptionShown){
						$scope.hideModal('quoteNotesDescriptionHelpModal');
						hideNotesDescription();
					}else{
						broadCastHandleBack();
					}
					break;
				case 3:
					broadCastHandleBack();
					break;
				case 4:
					broadCastHandleBack();
					break;
			}
		}
		
		/**
		 * function to broadcast the back button
		 */
		function broadCastHandleBack(){
			$scope.hideHeaderButton();
			$state.go('quotes');
			//$rootScope.$broadcast("handleBack");
		}
		
		/**
		 * function to override the back button
		 */
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
	}
})();

(function () {
    'use strict';

    quotesController.$inject = ['$scope', '$state', 'quotesFactory', 'quoteListCacheService', 'filterPreferences', '$rootScope', 'loginFactory', 'loadingOverlayService'];
    angular.module('ccMobile.requests')
        .controller('quotesController', quotesController);

    /**
     * quotes controller main function. controls the list of quotes populated on the quotes list page and the filters applied.
     */
    function quotesController($scope, $state, quotesFactory, quoteListCacheService, filterPreferences, $rootScope, loginFactory, loadingOverlayService) {

        $rootScope.showDetailsHeaderButton = false;


        $scope.filters = filterPreferences.filters;
        $scope.filterPriority = ['json.ApplUpdateDT', '-json.ApplUpdateDT', 'json.ResellerNM', '-json.ResellerNM', 'json.RequestRevisionNM', '-json.RequestRevisionNM', 'json.WorkflowStatusTX'];
        $scope.appliedFilters = angular.copy(filterPreferences.filters);
        $scope.filterActive = undefined;
        $scope.limitTo = filterPreferences.limitTo;

        $scope.showModifyQuote = showModifyQuote;
        $scope.removeModifyQuote = removeModifyQuote;
        $scope.modifyQuote = modifyQuote;
        $scope.closeHelpModal = closeHelpModal;
        $scope.redirectToQuotesDetailPage = redirectToQuotesDetailPage;
        $scope.isSelected = isSelected;
        $scope.addFilter = addFilter;
        $scope.applyFilters = applyFilters;
        $scope.cancelFilters = cancelFilters;


        function viewContentLoaded() {
            document.getElementsByTagName("r2o-content")[0].children[0].onscroll = loadMore;
        }

        WL.App.overrideBackButton(function (e) {
            e.preventDefault();
            $rootScope.$broadcast("handleBack");
        });

        $scope.$on('online', function () {

        });

        $scope.$on('offline', function () {

        });

        $scope.$on('$viewContentLoaded', viewContentLoaded);

        loadData();

        /**
         * function to load the quotes in the quotes list page
         */
        function getLocalQuotes() {
            quoteListCacheService.getQuotes()
                .then(function (quotes) {
                    var invocationData = {
                        adapter: 'CreateRequestAdapter',
                        procedure: 'getProductSpecificQuestions',
                        parameters: []
                    };
                    var options = {
                        onSuccess: success,
                        onFailure: failure,
                        invocationContext: {}
                    };
                    var tryCount = 2;

                    function success(result) {
                        loadingOverlayService.hide();
                        if (result.invocationResult.isSuccessful) {
                            var hashId = parseInt(localStorage.getItem("hashId") || '-1');
                            if (hashId != result.invocationResult.hashId) {
                                localStorage.setItem("productsRequiringQuestions", JSON.stringify(result.invocationResult.data));
                            }
                        }
                    }

                    function failure() {
                        if (tryCount != 0) {
                            WL.Client.invokeProcedure(invocationData, options);
                            tryCount--;
                        } else {
                            loadingOverlayService.hide();
                            WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
                                text: "OK"
                            }]);
                        }

                    }

                    $scope.quotes = quotes;
                    $scope.requestsErrorMessage = "No recent requests found.";
                    if ((localStorage.getItem(localStorage.getItem('LoginId') + 'hideRequestsHelpScreen') != "true") && ($scope.quotes != undefined && $scope.quotes.length > 0)) {
                        localStorage.setItem(localStorage.getItem('LoginId') + 'hideRequestsHelpScreen', "true");
                        angular.element(document).ready(function () {
                            $scope.revealedrequestIdIndex = 0;
                            $rootScope.$broadcast("toggle-quotesHelpModal");
                        });
                    }
                    loadingOverlayService.show();
                    WL.Client.invokeProcedure(invocationData, options);
                }, function () {
                    $scope.requestsErrorMessage = "Unable to retrieve requests, please check your connection and try again.";
                    WL.SimpleDialog.show("Service Unavailable", "Unable to retrieve requests, please check your connection and try again.", [{
                        text: "OK",
                        handler: function () {
                        }
                    }]);
                });
        }

        /**
         * wrapper function to call the service and to load the quotes list
         */
        function loadData() {
            quotesFactory.loadQuotesData()
                .then(getLocalQuotes, function (error) {
                    $scope.requestsErrorMessage = "Unable to retrieve requests, please check your connection and try again.";
                    WL.SimpleDialog.show("Service Unavailable", "Unable to retrieve requests, please check your connection and try again.", [{
                        text: "OK",
                        handler: function () {
                        }
                    }]);

                });
        }


        /**
         * function to load the next 20 quotes in the list
         */
        function loadMore() {
            var scrolledDistance = document.getElementsByTagName("r2o-content")[0].children[0].offsetHeight + document.getElementsByTagName("r2o-content")[0].children[0].scrollTop;
            var scrollableDistance = document.getElementsByTagName("r2o-content")[0].children[0].scrollHeight - 40;
            if (scrolledDistance > scrollableDistance) {
                $scope.$apply(function () {
                    $scope.limitTo = $scope.limitTo + 10;
                    filterPreferences.limitTo = $scope.limitTo;
                });
            }
        }

        function isSelected(filter) {
            if ($scope.filters.indexOf(filter) != -1) {
                return "selected";
            } else {
                return "unselected";
            }
        }

        /**
         * function to apply the filtes in the quotes list page
         *
         */
        function applyFilters() {
            var appliedFilters = $scope.filters.sort(function (a, b) {
                return $scope.filterPriority.indexOf(a) - $scope.filterPriority.indexOf(b);
            });
            filterPreferences.filters = angular.copy(appliedFilters);
            $scope.appliedFilters = angular.copy(appliedFilters);
            document.getElementsByTagName("r2o-content")[0].children[0].scrollTop = 0;
        }

        /**
         * function to cancel the filters
         */
        function cancelFilters() {
            $scope.filters = angular.copy($scope.appliedFilters);
        }

        /**
         * function to add a particular filter
         */
        function addFilter(isRadio, filter, ascending) {
            if (isRadio) {
                var ascendingFilter = $scope.filters.indexOf(filter);
                var descendingFilter = $scope.filters.indexOf("-" + filter);
                var filterToAdd, filterToremove;
                if (ascendingFilter == -1 && descendingFilter == -1) {
                    filterToAdd = (ascending == true ? "" : "-") + filter;
                    $scope.filters.push(filterToAdd);
                } else if (ascendingFilter != -1 && ascending == true) {
                    filterToremove = $scope.filters.indexOf(filter);
                    $scope.filters.splice(filterToremove, 1);
                } else if (descendingFilter != -1 && ascending == false) {
                    filterToremove = $scope.filters.indexOf("-" + filter);
                    $scope.filters.splice(filterToremove, 1);
                } else if (ascendingFilter != -1 && ascending == false) {
                    filterToAdd = "-" + filter;
                    filterToremove = $scope.filters.indexOf(filter);
                    $scope.filters.splice(filterToremove, 1);
                    $scope.filters.push(filterToAdd);
                } else if (descendingFilter != -1 && ascending == true) {
                    filterToAdd = filter;
                    filterToremove = $scope.filters.indexOf("-" + filter);
                    $scope.filters.splice(filterToremove, 1);
                    $scope.filters.push(filterToAdd);
                }
            } else {
                if ($scope.filters.indexOf(filter) == -1) {
                    $scope.filters.push(filter);
                } else {
                    $scope.filters.splice($scope.filters.indexOf(filter), 1);
                }
            }
        }

        /**
         * function to show the modifyQuote
         */
        function showModifyQuote(index, event) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            $scope.revealedrequestIdIndex = index;
        }

        /**
         * function to hide the modifyQuote
         */
        function removeModifyQuote(index, event) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            if (index == $scope.revealedrequestIdIndex) {
                $scope.revealedrequestIdIndex = "-1";
            }
        }

        /**
         * function to navigate the user to revise quote
         * @param quote object
         */
        function modifyQuote(quote) {
            $state.go('selectItemtoRevise');
        }

        /**
         * function to redirect the user to the QuotesDetailPage
         * @param requestRevisionSK
         */
        function redirectToQuotesDetailPage(requestRevisionSK) {
            localStorage.setItem('RequestRevisionSK', requestRevisionSK);
            $rootScope.goToState('quoteDetail');
        }

        /**
         * function to close the help modal
         */
        function closeHelpModal() {
            $scope.revealedrequestIdIndex = -1;
            $rootScope.$broadcast("toggle-quotesHelpModal");
        }
    }
})();

/**
 * 
 */
(function(){
	"use strict";
	
	angular.module("ccMobile.requests")
		.controller('ccViewController', ['$rootScope', '$scope', '$state', function($rootScope,$scope, $state){
			$rootScope.$broadcast("changeNavTitle",$scope.title);

			$scope.$watch('title', function(newValue, oldValue){
				console.log('title changed', newValue, oldValue);
				$rootScope.$broadcast('changeNavTitle',$scope.title);
			});

		}])
		.directive('ccView', function(){
			return {
				transclude: true,
				restrict : "E",
				scope : {
					title : "@"
				},
				template : "<div class='av-custom-title-bar  grid-block'><div class='small-grid-block'></div><div class='grid-block'><h1>{{title}}</h1></div><div class='small-grid-block'></div></div>"+
				"<div ng-transclude class='grid-block vertical'>"+
				"</div>",
				controller : "ccViewController"
			};
		});

	

})();

/**
 * 
 */
(function(){
	"use strict";

	angular.module("ccMobile.requests")
		.directive('whenScrolled', function() {
			console.log('scroll running');
		    return function(scope, elm, attr) {
		        var raw = elm[0];
		    	console.log('whenScrolled running');
		        
		        elm.bind('scroll', function() {
		            if (raw.scrollTop + raw.offsetHeight >= raw.scrollHeight) {
		                scope.$apply(attr.whenScrolled);
		            }
		        });
		    };
		});

})();


/**
 * r2o-alphabet-scrolling Directive
 * Add this directive to get Alphabetical Scrolling
 * Require :
 * scroll-in attribute - When user drags on alphabetical scroll it will scroll the element with id as the passed scroll-in value 
 */

(function(){
	'use strict';
	
	angular.module("ccMobile.requests")		
		.controller('r2oAlphabetScrollingController',r2oAlphabetScrollingController)
		.filter('r2oAddAlphabetClass',r2oAddAlphabetClassFilter)
		.directive('r2oAlphabetScrolling',r2oAlphabetScrolling);

		r2oAlphabetScrollingController.$inject = ['$scope'];

		/** Alphabetical Scrolling Directive's Controller */
		function r2oAlphabetScrollingController($scope){
			$scope.alphabets=['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','#'];
		}

		/** Angular Filter: if input's first character is between a-z or A-Z returns upper case of that letter otherwise returns #*/
		function r2oAddAlphabetClassFilter(){
			return function(input) {
				if(input.charCodeAt(0)>=65 && input.charCodeAt(0)<=122)
					return input.charAt(0).toUpperCase();
				return '#';
			};
		}


		function r2oAlphabetScrolling(){
			return {
				transclude: true,
				restrict : "E",
				controller:r2oAlphabetScrollingController,
				link: function(scope, element, attr){
					var scrollInElement=document.getElementById(attr.scrollIn);
					function scrollList(event){
						var touchedElement=document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
						try{
							var touchedFirstAlphabetElement=scrollInElement.getElementsByClassName(touchedElement.innerHTML)[0];
							scrollInElement.scrollTop=touchedFirstAlphabetElement.offsetTop - touchedFirstAlphabetElement.parentNode.offsetTop;
							event.preventDefault();
						}
						catch(e){
							event.preventDefault();
						}
					}

					function touchstartCallback(event){
						if(device.version < 4.4){
							scrollInElement.style.cssText = "overflow-y:hidden;";
						}
						scrollList(event);
					}

					function touchmoveCallback(event){
						scrollList(event);
					}

					function touchendCallback(event){
						if(device.version < 4.4){
							scrollInElement.style.cssText = "overflow-y:auto;";
						}
					}

					element[0].ontouchstart=touchstartCallback;
					element[0].ontouchmove=touchmoveCallback;
					element[0].ontouchend=touchendCallback;
				},  
				template : "<div class='alphabet' ng-repeat='alphabet in alphabets'>"+
		    			   "	{{alphabet}}"+
		    			   "</div>"
			};
		}
})();
/**
 * r2o-auto-complete Directive 
 * Require :
 * min-chars, on-change, ng-model attributes
 */
(function(){
	'use strict';
	
	angular.module("ccMobile.requests")		
		.directive('r2oAutoComplete', r2oAutoComplete);
	
	function r2oAutoComplete(){
		return {
			restrict:'A',
            require: "?ngModel",
            scope : {
            	ngModel : "=",
            	minChars : "=",
            	waitTime:"=",
            	onChange : "&"
            },
            link:function(scope,element, attrs){
            		function inputChanged(){
            			clearInterval(scope.timer);
            			scope.onChange();
            			scope.indexAtCallMade = scope.ngModel.length;
            			scope.textAtCallMade = angular.copy(scope.ngModel);
            		}
            		
            		scope.canGetNewData = true;
		            scope.$watch('ngModel', function(){
		            	clearInterval(scope.timer);
		            	
		            	if(scope.indexAtCallMade && scope.ngModel){
		            		if(scope.indexAtCallMade >= scope.ngModel.length && scope.textAtCallMade!=scope.ngModel){
		            			scope.canGetNewData = true;
		            		}else{
		            			scope.canGetNewData = false;
		            		}
		            	}
		            	
		            	if(scope.canGetNewData && scope.ngModel && scope.ngModel.length >= parseInt(scope.minChars || 3)){
		            		scope.timer = setInterval(inputChanged, parseInt(scope.waitTime || 500));
		            	}
		            });
            }
		};
	}
})();
/**
 * r2o-check-box Directive 
 * It adds styled checkbox
 */
(function(){
	'use strict';
	
	angular.module("ccMobile.requests")		
		.directive('r2oCheckBox', r2oCheckBox);
	
	function r2oCheckBox(){
		return {
			transclude: true,
			restrict : "E",
			scope:{
				isSelected : "="
			},
			link : function(scope, element, attrs){
				scope.toggle = toggle;
				if(attrs.checkBoxSide == 'right'){
					scope.checkBoxSide = "right";
				}else{
					
				}
				function toggle(){
						if(scope.isSelected == undefined || scope.isSelected == null){
							console.log("toggling to true");
							scope.isSelected = true;
						}else{
							console.log("toggling");
							scope.isSelected = !scope.isSelected;
						}
				}
			},
			template :  '<div ng-click="toggle()" class="checkBoxWrapper {{isSelected ? \'selected\' : \'\'}}">'+
							'<div ng-hide="checkBoxSide" class="checkBox">'+
								'<i class="icon-checkmark"></i>'+
							'</div>'+
							'<div class="checkBoxContent" style="text-align:{{checkBoxSide}}" ng-transclude></div>'+
							'<div ng-show="checkBoxSide" ng-show="" class="checkBox">'+
								'<i class="icon-checkmark"></i>'+
							'</div>'+
						'</div>'
		};
	}
})();
/**
 * r2o-content Directive 
 * Content of the view should be added in this directive
 */
(function(){
	'use strict';
	
	angular.module("ccMobile.requests")		
		.directive('r2oContent', r2oContent);
	
	function r2oContent(){
		return {
			transclude: true,
			restrict : "E", 
			template : "        <div ng-transclude class='grid-block vertical'>" +  
				      "        </div>"
		};
	}
})();
/**
 * r2o-filter-item Directive 
 * Adds styled filter item
 */
(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
	.directive('r2oFilterItem', r2oFilterItem);
	
	function r2oFilterItem(){
		return {
			restrict : "E", 
			scope : {
				title : "@"
			},
			template : "        <div>" + 
					   "           <div class='filterCheck'></div>" +
					   "            <h1 class='filterTitle'>{{title}}</h1>" +
				       "        </div>"
		};
	}
})();
/**
 * r2o-footer Directive 
 * Adds styled footer to the view
 */
(function(){
	'use strict';
	
	angular.module("ccMobile.requests")
		.directive('r2oFooter', r2oFooter);
	
	function r2oFooter(){
		return {
			transclude: true,
			restrict : "E", 
			template : "        <div ng-transclude>" +  
				       "        </div>"
		};
	}
})();
/** Contains r2o-menu and r20-menu-close directives */
(function(){
	'use strict';
	
	angular.module("ccMobile.requests")
		.controller("r2oMenuController", r2oMenuController)
		.directive("r2oMenu",r2oMenu)
		.directive('r2oMenuClose',r2oMenuClose);
	
		r2oMenu.$inject = ['$rootScope'];
		r2oMenuController.$inject = ['$scope'];
		
		/** r2o-menu directive's controller */
		function r2oMenuController($scope){
			$scope.showMenuContent = false;
			$scope.toggleMenu = toggleMenu;
			
			/** Toggle the show/hide of Menu. Also animates the menu button between 3-bar button and close button */			
			function toggleMenu(){
				$scope.showMenuContent = !$scope.showMenuContent;
				if($scope.opened=='active'){
					$scope.opened='';
					$scope.menuTopClick = '';
					$scope.menuMiddleClick = '';
					$scope.menuBottomClick = '';
					document.getElementsByTagName("r2o-content")[0].ontouchstart = function(){return true;};
				}
				else{
					$scope.opened='active';
					$scope.menuTopClick = 'menu-top-click';
					$scope.menuMiddleClick = 'menu-middle-click';
					$scope.menuBottomClick = 'menu-bottom-click';
					document.getElementsByTagName("r2o-content")[0].ontouchstart = closeMenu;
				}
			}
			
			$scope.$on('close-menu', closeMenu);
			
			
			function closeMenu(){
				$scope.$apply(function(){
					if($scope.showMenuContent){
						$scope.showMenuContent = false;
						$scope.opened='';
						$scope.menuTopClick = '';
						$scope.menuMiddleClick = '';
						$scope.menuBottomClick = '';
						document.getElementsByTagName("r2o-content")[0].ontouchstart = function(){return true;};
					}
				});
			}
					
		}
		
		/**
		 * r2o-menu Directive 
		 * Intially 3-bars buttons is added and when cliked on it, it'll animate and turns into close button and shows the Menu
		 * When clicked on the close button, it'll animate and turns into 3-bars Menu button and hides the Menu
		 */

		function r2oMenu($rootScope){
			return {
				restrict : "E",
				controller : "r2oMenuController",
				transclude : true,
				template : "<div ng-show='showMenuContent==true'  class='r2oMenuContent' ng-click='toggleMenu()'>"+
						   "    <div ng-transclude></div>"+
						   "</div>"+
						   "<button r2o-modal-close='filterModal' class='menuButton' ng-click='toggleMenu()'>"+
						   		"<div class='menuToggle'>"+
						            "<span class='menu-global menu-top {{menuTopClick}}'></span>"+
						            "<span class='menu-global menu-middle {{menuMiddleClick}}'></span>"+
						            "<span class='menu-global menu-bottom {{menuBottomClick}}'></span>"+
						        "</div>"+
						   "</button>"
			};
		}
		
		r2oMenuClose.$inject = ['$rootScope'];
		/**
		 * r2o-menu-close Directive 
		 * It is an attribute directive. Add this directive as an attribute to an element, cliked on which closes the menu
		 */
		function r2oMenuClose($rootScope){
			return {
				restrict : "A", 
				link: function(scope, element, attrs)
	            {
					element.on('click', function(){
	                	$rootScope.$broadcast("close-menu");
	                });
	            }
			};
		}
})();
/** Contains r2o-modal, r2o-modal-toggle and r2o-modal-close directives */
(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
	.directive('r2oModal', r2oModal)
	.directive('r2oModalToggle', r2oModalToggle)
	.directive('r2oModalClose',r2oModalClose);
	r2oModal.$inject = ['$rootScope', '$timeout'];

	/**
	 * r2o-modal Directive 
	 * Adds a modal
	 * Attributes:
	 * modal: Required attribute. Should be unique for each modal used 
	 * showViewHeader: if true will show the View's header 
	 * useParentFooter: if true shows parent's footer 
	 * enableTouchClose: if true closes the modal when touched on it 
	 * touch-call-back-method: if enableTouchClose is true, this method is called when touched on the modal
	 */
	function r2oModal($rootScope, $timeout){
		return {
			transclude: true,
			restrict : "E", 
			scope :{
				touchCallBackMethod:'&'
			},
			link : function(scope, element, attrs){
				if(attrs.useparentfooter != undefined && attrs.useparentfooter == "false"){
					//element.css('z-index',9999);
					scope.useParentFooter = 9999; 
				}else{
					element.css('z-index',99);
					scope.useParentFooter = 99;
				}
				if(attrs.enabletouchclose=="true"){
					element[0].ontouchstart=function(){
						scope.touchCallBackMethod();
					}
				}
				
				scope.$on("toggle-"+attrs.modal, function(){
					$timeout(function(){
						scope.$apply(function(scope){
							if(attrs.showviewheader!="true"){
								if($rootScope.modalShown=='increaseZIndex'){
									$rootScope.modalShown=undefined;
									scope.filterActive = undefined;
								}
								else{
									$rootScope.modalShown='increaseZIndex';
									scope.filterActive = "activeButton";
								}
							}
							scope.show = !scope.show;
							if(device.platform=='iOS'){
								$rootScope.showHeaderOverlay= !$rootScope.showHeaderOverlay;
							}
						});	
					});	
				});
				
				scope.$on('close-'+attrs.modal, function(){
					scope.$apply(function(){
						if(scope.show){
							scope.show = false;
							$rootScope.modalShown=undefined;
							scope.filterActive = undefined;
							$rootScope.showHeaderOverlay=false;
						}
					});
				});
			},
			template : "        <div class='r2oModal' style='z-index:{{useParentFooter}};' class='grid-block vertical' ng-show='show'>" + 
					   "            <div class='r2oModalContent' ng-transclude></div>"+
				       "        </div>"
		};
	}
	
	r2oModalClose.$inject = ['$rootScope'];

	/**
	 * r2o-modal-close Directive 
	 * Its an attribute directive. When this directive is used as an attribute to an element, the click on 
	 * the element will close the modal with the modal attribute value same as the value passed to r2o-modal-close attribute
	 */
	function r2oModalClose($rootScope){
		return {
			restrict : "A", 
			link: function(scope, element, attrs)
            {
				var modal = attrs.r2oModalClose;
				element.on('click', function(){
                	$rootScope.$broadcast("close-"+modal);
                });
            }
		};
	}
	
	r2oModalToggle.$inject = ['$rootScope'];

	/**
	 * r2o-modal-toggle Directive 
	 * Its an attribute directive. When this directive is used as an attribute to an element, the click on 
	 * the element will toggle the hide/show of the modal with the modal attribute value same as the value passed to r2o-modal-toggle attribute
	 */
	function r2oModalToggle($rootScope){
		return {
			restrict : "A", 
			link: function(scope, element, attrs)
            {
				var modal = attrs.r2oModalToggle;
				element.on('click', function(){
                	$rootScope.$broadcast("toggle-"+modal);
                });
            }
		};
	}
	
})();
/** Contains r2o-nav-bar and r2o-nav-back directives */
(function(){
	'use strict';
	
	angular.module("ccMobile.requests")
	.directive('r2oNavBar', r2oNavBar)
	.directive('r2oNavBack', r2oNavBack);
	
	/**
	 * r2o-nav-bar Directive 
	 * Add a nav bar
	 */
	function r2oNavBar(){
		return {
			transclude: true,
			restrict : "E",
			template :"            <div class='pageTitle'>" + 
				      "                {{title}}" + 
				      "            </div>"
		};
	}
	
	r2oNavBack.$inject = ['$rootScope'];

	/**
	 * r2o-nav-back Directive 
	 * Its an attribute directive. When this directive is used as an attribute to an element, the click on the element 
	 * will broadcast the handleBack event which handle the back button functionality
	 */
	function r2oNavBack($rootScope){
		return {
			restrict : "A", 
			link: function(scope, element, attrs)
            {
				element.on('click', function(){
                	$rootScope.$broadcast("handleBack");
                });
            }
		};
	}
	
})();
/**
 * r2o-nav-view Directive 
 * Handles Back button functionality, nav-bar title changes
 */
(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
		.controller('r2oNavViewController',r2oNavViewController)
		.directive('r2oNavView', function() {
			return {
				transclude: true,
				restrict : "E",
				controller : 'r2oNavViewController',
				template : "<div ng-transclude class='grid-block vertical'></div>"
			};
		});
		
	r2oNavViewController.$inject = ['$rootScope', '$scope', '$state', '$timeout'];
	
	function r2oNavViewController($rootScope, $scope, $state,$timeout){
			
			$scope.slideReverse='slideForward';
			$scope.title = "";
			$scope.stateStack = [];	
			$scope.goBack = goBack;
			$rootScope.$on("changeNavTitle", changeNavTitle);
			$rootScope.$on("$stateChangeStart", stateChangeStart);
			
			function changeNavTitle(event,title){
				$timeout(function(){
					$scope.title = title;
				},100);// added timeout to change title after page transition 
			}
			$rootScope.menuItems = ["login","quotes","newRequest","submissionSuccessful", "reviseSubmissionSuccessful"];
			
			function stateChangeStart(event, toState, toParams, fromState, fromParams){
				if(toState.name != "login"){
					if($rootScope.menuItems.indexOf(toState.name) == -1){
						//if user navigating to inner states other than menu items
						
						if($scope.stateStack.indexOf(toState.name) == -1){	
							//going to deeper views
							$scope.stateStack.push(toState.name);
						}else{
							//coming out of detail view
							$scope.stateStack.pop();
						}
					}else{
						// if user navigating to state in menu items
						$scope.stateStack.length = 0;
						$scope.stateStack.push(toState.name);
					}
				}else{
					$scope.stateStack.length = 0;
				}
				
				$timeout(function(){
					$scope.slideReverse='slideForward';
				},1000);
			}
			
			$scope.$on("handleBack", handleBack);
			
			function goBack(stateParams){
				$scope.slideReverse='slideReverse';		
				setTimeout(function(){
					$state.go("^."+$scope.stateStack[$scope.stateStack.length - 2], stateParams);
				},100);
			};
			
			function handleBack(event, args){
				console.log('handleBack: ', event, args);
				if($scope.stateStack.length>1){
					goBack(args);
				}else{
					WL.App.close();
				}
			}
			
			document.addEventListener(WL.Events.WORKLIGHT_IS_CONNECTED, connectionDetected, false);
			document.addEventListener(WL.Events.WORKLIGHT_IS_DISCONNECTED, disconnectionDetected, false);

			function connectionDetected(){
				console.log('connected to network');
				//$rootScope.$broadcast('online');
				$rootScope.$apply(function(){
					$rootScope.networkStatus='online';
				});
			}

			function disconnectionDetected(){
				console.log('disconnected from network');
				//$rootScope.$broadcast('offline');
				$rootScope.$apply(function(){
					$rootScope.networkStatus='offline';
				});
			}
			
		}
})();
/**
 * r2o-product-question Directive 
 * Based on type of the question-type loads the respective html template
 * Attributes:
 * question,
 * productIndex 
 * questionIndex
 * currentContract
 * addOption
 * isOptionAdded
 */
(function(){
	'use strict';
	
	angular.module("ccMobile.requests")		
		.directive('r2oProductQuestion', r2oProductQuestion);
	
	r2oProductQuestion.$inject = ['$compile', '$http', '$templateCache', '$timeout'];
	function r2oProductQuestion($compile, $http, $templateCache,$timeout){
		
		var getTemplate = function(type) {
			var templateUrl = "";
			switch(type){
				case "select" :
					templateUrl = "app/modules/requests/directives/productSpecificQuestionTemplates/questionSelect.html";
					break;
				case "multiSelect" :
					templateUrl = "app/modules/requests/directives/productSpecificQuestionTemplates/questionMultiSelect.html";
					break;
				case "radio" :
					templateUrl = "app/modules/requests/directives/productSpecificQuestionTemplates/questionRadio.html";
					break;
				default :
					templateUrl = "app/modules/requests/directives/productSpecificQuestionTemplates/questionInput.html";
			}
            var templateLoader = $http.get(templateUrl, {cache: $templateCache});

            return templateLoader;
        };
        
        var linker = function(scope, element, attrs){
        	/*scope.currentContract=true;*/
        	scope.blurElementWithId=blurElementWithId;
        	scope.showInViewElementWithId=showInViewElementWithId;
        	
        	var loader = getTemplate(scope.question.questionType);
            loader.success(function(html) {
                element.html(html);
            }).then(function (response) {
                element.replaceWith($compile(element.html())(scope));
            });

            function showInViewElementWithId(id){
            	if(cordova.platformId!="ios"){
            		$timeout(function() { 
						document.getElementById(id).scrollIntoView(true);
					},1000);
            	}
        	}
        	
        	function blurElementWithId(id){
				$timeout(function() { 
					document.getElementById(id).blur();
				});
			}
        };
		
		return {
			restrict : "E",
			scope : {
				question : "=",
				productIndex : "=",
				questionIndex : "=",
				currentContract : "=",
				addOption : "&",
				isOptionAdded: "&"
			},
			link : linker
		};
	}
	
})();
/** Contains r2o-slide-box and r2o-slide directives */
(function(){
	'use strict';
	
	angular.module("ccMobile.requests")	
	.controller('r2oSlideBoxController', r2oSlideBoxController)
	.directive('r2oSlideBox', r2oSlideBox)
	.controller('r2oSlideController',r2oSlideController)
	.directive('r2oSlide', r2oSlide);
	
	r2oSlideBoxController.$inject = ['$scope'];

	/** r2o-slide-box directive's controller */
	function r2oSlideBoxController($scope){
		$scope.windowWidth = window.innerWidth;
		$scope.slideBoxWidth = parseInt($scope.items) * window.innerWidth;
		$scope.goLeft = goLeft;
		$scope.goRight = goRight;
		window.onresize = resize;
		
		$scope.$watch('items', function(old, n){
			$scope.slideBoxWidth = parseInt($scope.items) * window.innerWidth;
		});
		
		function resize(){
			console.log("window resized");
			$scope.$apply(function(){
				$scope.windowWidth = window.innerWidth;
				$scope.slideBoxWidth = parseInt($scope.items) * window.innerWidth;
			});
		}
		
		function goLeft(){
			if($scope.swipe == "true"){
				if($scope.index.index < $scope.items){
					$scope.index.index = parseInt($scope.index.index)+1;				
				}
			}
		}
		
		function goRight(){
			if($scope.swipe == "true"){
				if($scope.index.index > 1){
					$scope.index.index = parseInt($scope.index.index)-1;
				}
			}
		}
	}
	
	/**
	 * r2o-slide-box Directive 
	 * Contains r2o-slide elements and provides methods to goLeft and goRight to move between r2o-slide elements 
	 */
	function r2oSlideBox(){
		return {
			transclude: true,
			controller : 'r2oSlideBoxController',
			restrict : "E",
			scope : {
				items : "=",
				index : "=",
				swipe : "@"
			},
			link : function(scope, element, attrs){
				scope.ele = document.getElementsByTagName("r2o-content")[0].children[0];
			},
			template : "<div ng-transclude class='slideBox' style='width:{{slideBoxWidth}}px; height:{{ele.clientHeight}}px; -webkit-transform:translateX(-{{(index.index-1)*windowWidth}}px); -ms-transform:translateX(-{{(index.index-1)*windowWidth}}px); transform:translateX(-{{(index.index-1)*windowWidth}}px);' ng-swipe-left='goLeft()' ng-swipe-right='goRight()'>" +  
				       "</div>"
		};
	}
	
	r2oSlideController.$inject = ['$scope'];

	/** r2o-slide directive's controller */
	function r2oSlideController($scope){
		$scope.windowWidth = window.innerWidth;
	}
	
	/**
	 * r2o-slide Directive 
	 * Has styles of taking entire height of enclosed r2o-slide-box and screen width of the 
	 */
	function r2oSlide(){
		return {
			transclude: true,
			link : function(scope, element, attrs){
				scope.ele = document.getElementsByTagName("r2o-content")[0].children[0];
			},
			controller : 'r2oSlideController',
			restrict : "E",
			template : "<div ng-transclude class='slide' style='width:{{windowWidth}}px; max-height: {{ele.clientHeight}}; min-height: {{ele.clientHeight}};'>" +  
				       "</div>"
		};
	}
})();
/**
 * r2o-toggle Directive 
 * Adds Styled Toggle Button
 * Also adds the click to toggle and SwipeRight/SwipeLeft to Enable/Disable functionality
 */
(function(){
	'use strict';
	
	angular.module("ccMobile.requests")		
		.directive('r2oToggle', r2oToggle);
	
	function r2oToggle(){
		return {
			restrict:'E',
			translude : true,
			scope : {
				isChecked : "="
			},
            link:function(scope,element, attrs){
            	var prevX,currX;
            	var touchStartTime,touchEndTime;
            	function touchstartCallback(event){
            		console.log('in touchstartCallback');
            		event.preventDefault();
            		prevX=event.changedTouches[0].clientX;
            		touchStartTime=Date.now();
            		//console.log('prevX :'+prevX);
            	}

            	function touchmoveCallback(event){
            		console.log('in touchmoveCallback');
					event.preventDefault();
				}

				function touchendCallback(){
					console.log('in touchendCallback');
					touchEndTime=Date.now();
					currX=event.changedTouches[0].clientX;
					console.log('currX-prevX :'+currX-prevX);
					console.log('currX :'+currX);
					if(currX-prevX > 40 || currX-prevX < -40){
						if(currX-prevX>40){
							console.log('swiped right');
							scope.isChecked=true;
						}
						else if(currX-prevX<-40){
							console.log('swiped left');
							scope.isChecked=false;
						}
					}
					else{
						if(touchEndTime - touchStartTime <=150){
							console.log('toggle clikced');
							scope.isChecked=!scope.isChecked;
						}
					}
					scope.$apply();
				}

				element[0].children[0].ontouchstart=touchstartCallback;
				element[0].children[0].ontouchmove=touchmoveCallback;
				element[0].children[0].ontouchend=touchendCallback;
            },
            template:   '<div class="styledCheckBox" draggable="true">'+
							'<div class="checkBoxBackground " ng-class="isChecked ? \'selected\' : \'\'">'+
								'<div class="enableButton">'+
									
								'</div>'+
							'</div>'+
						'</div>'
		};
	}
})();
/**
 * r2o-view Directive 
 * 
 */
(function(){
	"use strict";
	
	angular.module("ccMobile.requests")
		.controller('r2oViewController', ['$rootScope', '$scope', '$state', function($rootScope,$scope, $state){
			$rootScope.$broadcast("changeNavTitle",$scope.title);

			$scope.$watch('title', function(newValue, oldValue){
				console.log('title changed', newValue, oldValue);
				$rootScope.$broadcast("changeNavTitle",$scope.title);
			});

		}])
		.directive('r2oView', function(){
			return {
				transclude: true,
				restrict : "E",
				scope : {
					title : "="
				},
				template : "<div ng-transclude class='grid-block vertical'></div>",
				controller : "r2oViewController"
			};
		});
})();
/** Contains r2o-webview-back, r2o-webview-forward, r2o-webview-close and r2o-webview-open directives */
(function(){
	"use strict";
	
	angular.module("ccMobile.requests")
		.directive('r2oWebviewBack', r2oWebviewBack)
		.directive('r2oWebviewForward', r2oWebviewForward)
		.directive('r2oWebviewClose', r2oWebviewClose)
		.directive('r2oWebviewOpen', r2oWebviewOpen);
		
		/**
		 * r2o-webview-back Directive 
		 * Its an attribute directive. When this directive is used as an attribute to an element, the click on 
		 * the element makes the webview go back
		 */
		function r2oWebviewBack(){
			return {
				restrict : "A",
				link: function(scope, element, attrs){
						element.on('click', function(){
							window.shopWebViewOverlay.goBack();
		                });
	            	}
			};
		}
		
		/**
		 * r2o-webview-forward Directive 
		 * Its an attribute directive. When this directive is used as an attribute to an element, the click on 
		 * the element makes the webview go forward
		 */
		function r2oWebviewForward(){
			return {
				restrict : "A",
				link: function(scope, element, attrs){
						element.on('click', function(){
							window.shopWebViewOverlay.goForward();
		                });
	            	}
			};
		}
		
		/**
		 * r2o-webview-close Directive 
		 * Its an attribute directive. When this directive is used as an attribute to an element, the click on 
		 * the element will close the webview overlay
		 */
		function r2oWebviewClose(){
			return {
				restrict : "A",
				link: function(scope, element, attrs){
						element.on('click', function(){
							window.shopWebViewOverlay.close();
		                });
	            	}
			};
		}
		
		/**
		 * r2o-webview-open Directive 
		 * Opens webview with the provided URL
		 */
		function r2oWebviewOpen(){
			return {
				restrict : "A",
				link: function(scope, element, attrs){
						element.on('click', function(){
							setTimeout(function(){
								window.shopWebViewOverlay.goToPage(attrs.url);
							}, 200);
		                });
	            	}
			};
		}
})();
/** global moment:false */
/**
*  Date Service
*
*  Provides methods for getting Current Date and formatting Dates
*/
(function () {
    'use strict';

    angular.module('ccMobile.requests')
        .factory('dateService', dateService);
    
    function dateService() {
        var service = {
            add: add,
            formatDate: formatDate,
            formatDateTime: formatDateTime,
            formatShortDate: formatShortDate,
            getDateFormatString: getDateFormatString,
            getDateTimeFormatString: getDateTimeFormatString,
            now: now
        };

        Date.prototype.today = function () {
            return (((this.getMonth() + 1) < 10) ? '0' :'') + (this.getMonth() + 1) + '/' + ((this.getDate() < 10) ? '0' : '') + this.getDate() + '/' + this.getFullYear();
        };

        Date.prototype.timeNow = function () {
            return ((this.getHours() < 10) ? '0' : '') + this.getHours() + ':' + ((this.getMinutes() < 10) ? '0' : '') + this.getMinutes() + ':' + ((this.getSeconds() < 10) ? '0' : '') + this.getSeconds();
        };

        function formatDate(dateField, format) {
            if (dateField) {
                if (format) {
                    return moment(dateField).format(format);
                } else {
                    return formatShortDate(dateField);
                }
            }
            return dateField;
        }

        /** Returns the short data of format 'MM/DD/YYYY' 
        *   dateField - date
        */
        function formatShortDate(dateField) {
            if (dateField) {
                return moment(dateField).format('MM/DD/YYYY');
            } else {
                return dateField;
            }

        }

        /** Returns the formatted data of format 'MM/DD/YYYY HH:mm:ss' 
        *   dateField - date
        */
        function formatDateTime(dateField) {
            if (dateField) {
                //return moment(dateField).format('MM/DD/YYYY h:mm:ss a');
                return moment(dateField).format('MM/DD/YYYY HH:mm:ss');
            } else {
                return dateField;
            }
        }

        function getDateFormatString() {
            return '{0: MM/dd/yyyy}';
        }
        
        function getDateTimeFormatString() {
            return '{0: MM/dd/yyyy HH:mm:ss}';
        }

        /** function to get the current date */
        function now() {
            return formatDateTime(moment());
        }

        function add(date, amount, period) {
            var periods = ['seconds', 'minutes', 'hours', 'days', 'weeks', 'months', 'years'];
            if (periods.indexOf(period) === -1) {
                throw new Error('Invalid period: ' + period);
            }
            return moment(date).add(amount, period);
        }
        return service;
    }
})();
var newReqResp, submitResp;
var productsCache;


/**
 *  New Request Service
 *
 *  Provides methods for getting data for creating Request, Submitting a New Request, Revising a Request and also stores
 *  the New Request Data until it is submitted.
 */
(function () {
    newRequestFactory.$inject = ['$q', 'loginCacheService', 'loadingOverlayService', 'productSpecificQuestionsCacheService', 'dateService'];
    angular.module('ccMobile.requests')
        .factory('newRequestFactory', newRequestFactory);

    var requiredResponse = [{
        id: 1,
        response: "Configure this request",
    }, {
        id: 4,
        response: "Configure and quote this request"
    }, {
        id: 5,
        response: "Quote this request"
    }];
    
    function newRequestFactory($q, loginCacheService, loadingOverlayService, productSpecificQuestionsCacheService, dateService) {
        productsCache = productSpecificQuestionsCacheService;
        var newRequestFactory = {
            //variables
            request: undefined,
            selectedReviseQuote: undefined,
            selectedReviseProduct: undefined,
            selectedRequestQuote: undefined,
            selectedReviseConfig: undefined,
            selectedReviseTab: 1,
            isReviseConfig: false,
            requiredResponse: [],
            productSpecificQuestions: [],
            temporaryNotificationEmails: [],
            removedProductIndexes: {},
            temporaryEmail: "",
            areQuestionsRequired: false,
            isSubmitButtonClicked: false,
            isQuestionsSaveClicked: false,
            isEndUserNotRequired: false,
            disclaimers: [],
            //methods
            getNewRequest: getNewRequest,
            getRequest: getRequest,
            setRequest: setRequest,
            submitRequest: submitRequest,
            submitReviseRequest: submitReviseRequest,
            getMatchedEndUsers: getMatchedEndUsers,
            getDisclaimer: getDisclaimer,
            updateProductSpecificQuestions: updateProductSpecificQuestions,
            addProductSpecificQuestions: addProductSpecificQuestions,
            removeProductSpecificQuestions: removeProductSpecificQuestions,
            resetNewRequest: resetNewRequest

        };

        /**  Returns the New Request Data that so far has been added */
        function getRequest() {
            return angular.copy(newRequestFactory.request);
        }

        /**  Sets the New Request Data
         *     @param request
         */
        function setRequest(request) {
            newRequestFactory.request = angular.copy(request);
        }

        /** Returns the New Request based on the type of Request(copy, modify or new)
         *    @param type - type of get New Request : copy, modify or new
         *    requestNo - requestNo to get copy or revise request
         */
        function getNewRequest(type, requestNo) {
            if (type == "copy") {
                return getNewRequestFromCopy(requestNo);
            } else if (type == "modify") {
                return getNewReviseRequest();
            } else {
                return getNewBlankRequest();
            }
        }

        /** Returns the New Blank Request */
        function getNewBlankRequest() {
            var defered = $q.defer();
            var authCredentials = loginCacheService.getLoginToken();
            var tryCount = 2;
            var invocationData = {
                adapter: 'CreateRequestAdapter',
                procedure: 'getRecentUsers',
                parameters: [authCredentials.cookie, authCredentials.sessionId, localStorage.getItem("IsInternal") == "true" ? null : authCredentials.emailAddress, localStorage.getItem("IsInternal")]
            };
            var options = {
                onSuccess: success,
                onFailure: failure,
                invocationContext: {}
            };

            function success(result) {
                addCookieValues(result.invocationResult.cookie);
                newReqResp = result;
                result.invocationResult.data.CurrencyCode = "USD";
                newRequestFactory.setRequest(result.invocationResult.data);
                defered.resolve(newRequestFactory.getRequest());
                loadingOverlayService.hide();
            }

            function failure(error) {
                console.log(error);
                loadingOverlayService.hide();
                if (tryCount != 0) {
                    loadingOverlayService.show();
                    WL.Client.invokeProcedure(invocationData, options);
                    tryCount--;
                } else {
                    defered.reject();
                }
            }

            loadingOverlayService.show();
            WL.Client.invokeProcedure(invocationData, options);
            newRequestFactory.productSpecificQuestions.length = 0;
            newRequestFactory.temporaryEmail = "";
            newRequestFactory.temporaryNotificationEmails.length = 0;
            newRequestFactory.isSubmitButtonClicked = false;
            newRequestFactory.areQuestionsRequired = false;
            newRequestFactory.isEndUserNotRequired = false;
            newRequestFactory.requiredResponse = angular.copy(requiredResponse);
            return defered.promise;
        }

        /** Returns the New Revise Request */
        function getNewReviseRequest() {
            var defered = $q.defer();
            var authCredentials = loginCacheService.getLoginToken();
            var tryCount = 2;
            var invocationData = {
                adapter: 'CreateRequestAdapter',
                procedure: 'getRecentUsers',
                parameters: [authCredentials.cookie, authCredentials.sessionId, localStorage.getItem("IsInternal") == "true" ? null : authCredentials.emailAddress, localStorage.getItem("IsInternal")]
            };
            var options = {
                onSuccess: success,
                onFailure: failure,
                invocationContext: {}
            };

            function success(result) {
                addCookieValues(result.invocationResult.cookie);
                result.invocationResult.data.CurrencyCode = "USD";
                newRequestFactory.setRequest(result.invocationResult.data);
                defered.resolve(newRequestFactory.getRequest());
                loadingOverlayService.hide();
            }

            function failure() {

                console.log("error");
                if (tryCount != 0) {
                    WL.Client.invokeProcedure(invocationData, options);
                    tryCount--;
                } else {
                    loadingOverlayService.hide();
                    defered.reject();
                }
            }

            loadingOverlayService.show();
            WL.Client.invokeProcedure(invocationData, options);
            return defered.promise;
        }

        /** Returns the New Request that has contents copied from provided requestNo Request
         *    @param requestNo - requestNo of request to be copied
         */

        function getNewRequestFromCopy(requestNo) {
            var defered = $q.defer();
            var authCredentials = loginCacheService.getLoginToken();
            var tryCount = 2;
            var invocationData = {
                adapter: 'CopyRequestAdapter',
                procedure: 'copyRequest',
                parameters: [authCredentials.cookie, authCredentials.sessionId, requestNo, localStorage.getItem("IsInternal")]
            };
            var options = {
                onSuccess: success,
                onFailure: failure,
                invocationContext: {}
            };

            /** Populates Product Specific Questions Data From Copy Request Product Attributes
             *   @param productAttributes - productAttributes from where we need to populate product specific questions and answers to them
             */

            function populateProductSpecificQuestionsFromCopy(productAttributes) {
                var productSpecificQuestions = newRequestFactory.productSpecificQuestions;
                for (var i = 0; i < (productSpecificQuestions || []).length; i++) {
                    //console.debug(productSpecificQuestions[i].productAttribute.EntityType + ' == '+productAttributes[i].EntityType);
                    var productQuestions = productSpecificQuestions[i].questions;
                    for (var j = 0; j < productQuestions.length; j++) {
                        if (productQuestions[j].questionType == "multiSelect") {
                            productQuestions[j].answer = [];
                            var allOptions = productQuestions[j].options;
                            for (var k = 0; k < allOptions.length; k++) {
                                if (productAttributes[i][allOptions[k].attributeProperty]) {
                                    productQuestions[j].answer.push(allOptions[k]);
                                }
                            }
                        } else if (productQuestions[j].questionType == "radio") {
                            productQuestions[j].answer = [];
                            var allOptions = productQuestions[j].options;
                            if (allOptions[0].attributeProperty.indexOf('IsMachineTypeNew') > -1) {
                                if (productAttributes[i]['IsMachineTypeNew'] == true) {
                                    productQuestions[j].answer.push(allOptions[0]);//first option is new
                                }
                                else if (productAttributes[i]['IsMachineTypeNew'] == false) {
                                    productQuestions[j].answer.push(allOptions[1]);// second option is used
                                }
                            }
                            else if (allOptions[0].attributeProperty.indexOf('SelectedTerm') > -1) {
                                productQuestions[j].answer.push(allOptions.filter(function (e) {
                                    if (e.attributeProperty == "SelectedTerm" + productAttributes[i]['SelectedTerm'] + "Yr") return e;
                                })[0]);
                            }
                            else if (allOptions[0].attributeProperty.indexOf('IsChange') > -1) {
                                if (productAttributes[i]['IsChange'] == true) {
                                    productQuestions[j].answer.push(allOptions[0]);//first option is change
                                }
                                else if (productAttributes[i]['IsChange'] == false) {
                                    productQuestions[j].answer.push(allOptions[1]);// second option is no change
                                }
                            }
                            else if (allOptions[0].attributeProperty.indexOf('CurrentContract') > -1) {
                                productQuestions[j].answer = productAttributes[i]['IsCurrentContract'];
                                /*else if(productAttributes[i]['IsCurrentContract']==false){
                                 productQuestions[j].answer.push(allOptions[0]);// second option is yes
                                 }*/
                            }
                            else if (allOptions[0].attributeProperty.indexOf('Channel') > -1 || allOptions[0].attributeProperty.indexOf('HPDirect') > -1) {
                                if (productAttributes[i]['ChannelHPDirect'] == true) {
                                    productQuestions[j].answer.push(allOptions[1]);//first option is no
                                }
                                else if (productAttributes[i]['ChannelHPDirect'] == false) {
                                    productQuestions[j].answer.push(allOptions[0]);// second option is yes
                                }
                            }
                            else if (allOptions[0].attributeProperty.indexOf('IsNotes') > -1 || allOptions[0].attributeProperty.indexOf('IsFiles') > -1) {
                                if (productAttributes[i]['IsFiles'] == true) {
                                    productQuestions[j].answer.push(allOptions[1]);//first option is no
                                }
                                else if (productAttributes[i]['IsFiles'] == false) {
                                    productQuestions[j].answer.push(allOptions[0]);// second option is yes
                                }
                            }
                            else if (allOptions[0].attributeProperty.indexOf('IsQuote') > -1) {
                                if (productAttributes[i]['IsQuoteContract'] == true) {
                                    productQuestions[j].answer.push(allOptions[1]);//first option is quote
                                }
                                else if (productAttributes[i]['IsQuoteContract'] == false) {
                                    productQuestions[j].answer.push(allOptions[0]);// second option is quote contract
                                }
                            }
                        } else if (productQuestions[j].questionType == "date") {
                            var dateString = productAttributes[i][productQuestions[j].attributeProperty];
                            if (!dateString) {
                                productQuestions[j].answer = null;
                            }
                            else {
                                dateString = dateString.split('/');
                                productQuestions[j].answer = new Date(dateString[2], dateString[0] - 1, dateString[1]);
                            }
                        } else if (productQuestions[j].questionType == "number") {
                            if (!productAttributes[i][productQuestions[j].attributeProperty]) {
                                productQuestions[j].answer = null;
                            }
                            else {
                                productQuestions[j].answer = parseInt(productAttributes[i][productQuestions[j].attributeProperty]);
                            }
                        } else {
                            productQuestions[j].answer = productAttributes[i][productQuestions[j].attributeProperty];
                        }
                    }
                }
            }

            /** Populates Product Specific Questions
             * @param products - products for which to which we need to populate product specific questions
             */
            function populateProductsAndQuestions(products) {
                console.log('in populateProductsAndQuestions');
                for (var i = 0; i < products.length; i++) {
                    products[i].productIndexCount = products.slice(0, i).filter(function (e) {
                            return e.EntityTemplateSk == products[i].EntityTemplateSk
                        }).length + 1;
                    newRequestFactory.addProductSpecificQuestions(products[i]);
                }
            }

            function success(result) {
                addCookieValues(result.invocationResult.cookie);
                newReqResp = result;
                result.invocationResult.data.addedEndUsers = result.invocationResult.data.Partners.filter(function (e) {
                    return e.PartnerRoleTypeCode == "SAPEUO"
                });
                /*if(result.invocationResult.data.addedEndUsers.length<1){
                 newRequestFactory.isEndUserNotRequired=true;
                 if(result.invocationResult.data.IsGovernmentRequest)
                 result.invocationResult.data.businessSector='Fed/Sled';
                 else
                 result.invocationResult.data.businessSector='Commercial';
                 }*/
                result.invocationResult.data.Partners = result.invocationResult.data.Partners.filter(function (e) {
                    return e.PartnerRoleTypeCode != "SAPEUO"
                });
                newReqResp.invocationResult.data.RequestName = "Copy of " + newReqResp.invocationResult.data.RequestName
                //result.invocationResult.data.requestInstructions=(result.invocationResult.data.RequestNotes.map(function(e){return e.NoteText;})).join('$$$');
                populateProductsAndQuestions(result.invocationResult.data.Products);
                newRequestFactory.setRequest(result.invocationResult.data);
                //updateProductSpecificQuestions();

                //chnaging product attributes to contain only the products with required questions
                var selectedProducts = newRequestFactory.request.Products || [];
                selectedProducts = selectedProducts.map(function (item) {
                    var object = {};
                    object['ProductSk'] = item.ProductSk;
                    object['EntityTemplateSk'] = item.EntityTemplateSk;
                    return object
                });
                var allProductSpecificQuestions = productSpecificQuestionsCacheService.getProductsRequiringQuestions();

                var allProductSpecificQuestionSks = allProductSpecificQuestions.map(function (item) {
                    return item.EntityTemplateSk;
                });

                var selectedProductsWithQuestionsSks = selectedProducts.filter(function (e) {
                    return allProductSpecificQuestionSks.indexOf(e.EntityTemplateSk) != -1
                }).map(function (e) {
                    return e.ProductSk
                });
                result.invocationResult.data.ProductAttributes = result.invocationResult.data.ProductAttributes.filter(function (e) {
                    return selectedProductsWithQuestionsSks.indexOf(e.ProductSk) != -1
                });
                result.invocationResult.data.ProductAttributes = result.invocationResult.data.ProductAttributes.sort(function (a, b) {
                    return a.ProductSk - b.ProductSk;
                });

                populateProductSpecificQuestionsFromCopy(result.invocationResult.data.ProductAttributes);
                defered.resolve(newRequestFactory.getRequest());
                loadingOverlayService.hide();
            }

            function failure() {

                console.log("newRequestService: getNewRequestFromCopy: error");
                if (tryCount != 0) {
                    WL.Client.invokeProcedure(invocationData, options);
                    tryCount--;
                } else {
                    loadingOverlayService.hide();
                    defered.reject();
                }
            }

            loadingOverlayService.show();
            WL.Client.invokeProcedure(invocationData, options);
            newRequestFactory.productSpecificQuestions.length = 0;
            newRequestFactory.temporaryEmail = "";
            newRequestFactory.temporaryNotificationEmails.length = 0;
            newRequestFactory.isSubmitButtonClicked = false;
            newRequestFactory.areQuestionsRequired = false;
            newRequestFactory.isEndUserNotRequired = false;
            newRequestFactory.requiredResponse = angular.copy(requiredResponse);
            return defered.promise;
        }

        /** Returns New Product with all the Product Data added
         * @param productSk - productSk of product
         * lookUpListProduct - lookUpListProduct
         */
        function getNewProduct(productSk, lookUpListProduct) {
            var productName = lookUpListProduct.SupplierName + " - " + lookUpListProduct.EntityTemplateName;
            /*if(productIndexCount>1){
             productName=productName+ " "+productIndexCount;
             }*/
            return {
                EntityType: "Product",
                ProductSk: productSk,
                RequestSk: 0,
                ProductName: productName,
                IsB2BCustomer: false,
                PriorityLevel: 0,
                WorkflowId: "",
                WorkflowVersion: 1,
                WorkflowStatus: "",
                EffectiveFromDate: null,
                IsConfigurable: false,
                IsAutoQuote: false,
                ConfigComplexityLevel: 1,
                IsPricingApproved: null,
                PricingExpireDate: null,
                PricingSupplierAuthNumber: null,
                EntityTemplateSk: lookUpListProduct.EntityTemplateSk,
                EntityTemplateName: lookUpListProduct.EntityTemplateName,
                SupplierName: lookUpListProduct.SupplierName,
                OldRequestNumber: 0,
                ProductGroupSk: lookUpListProduct.ProductGroupSk,
                ProductGroupName: lookUpListProduct.ProductGroupName,
                CreateDate: dateService.now(),
                UpdateDate: dateService.now(),
                DeleteDate: null,
                CreateUserId: localStorage.getItem("LoginId"),
                UpdateUserId: null,
                DeleteUserId: null,
                EntityTemplate: lookUpListProduct,
                ProductDetail: null
            };
        }

        /** Submits the New Request with all the data added -> Populating product Specific Questions, adding entire product Data of added Products,
         *    Properly updating the Notifications List etc.,
         */
        function submitRequest() {
            var defered = $q.defer();
            var authCredentials = loginCacheService.getLoginToken();
            var request = getRequest();
            //request notifications

            //adding lori.thompson@avnet.com if it is not present to gis.testing@avnet.com user
            if (localStorage.getItem("emailAddress").toLowerCase() == "gis.testing@avnet.com") {
                if ((request.notificationEmails || []).filter(function (contact) {
                        return !angular.isObject(contact);
                    }).indexOf("lori.thompson@avnet.com") == -1) {
                    if ((request.notificationEmails || []).filter(function (contact) {
                            return angular.isObject(contact)
                        }).map(function (contact) {
                            return contact.EmailAddress.toLowerCase()
                        }).indexOf("lori.thompson@avnet.com") == -1) {
                        (request.notificationEmails || []).push("lori.thompson@avnet.com");
                    }
                }
            }


            /*request.Contacts = (request.notificationEmails || []).filter(function(contact){
             return angular.isObject(contact);
             });*/

            var ccRecipients = (request.notificationEmails || []).filter(function (contact) {
                return angular.isObject(contact);
            }).map(function (item) {
                return item.EmailAddress
            });


            var adHocRecipients = (request.notificationEmails || []).filter(function (contact) {
                return !angular.isObject(contact);
            });

            request.Contacts = (newRequestFactory.getRequest().Contacts || []).filter(function (e) {
                return e.IsNotifyAssigned == false && e.IsNotifySuggested == true;
            });
            //Partners
            if (request.addedEndUsers.length > 0) {
                request.Partners.push(angular.copy(request.addedEndUsers[0]));
            }


            request.IsIntegration = false;
            request.IsGovernmentRequest = false;

            //product specific questions
            var productSpecificQuestions = newRequestFactory.productSpecificQuestions;
            for (var i = 0; i < (productSpecificQuestions || []).length; i++) {
                var productQuestions = productSpecificQuestions[i].questions;
                for (var j = 0; j < productQuestions.length; j++) {
                    var selectedOptions = productQuestions[j].answer;
                    if (productQuestions[j].questionType == "multiSelect") {
                        var allOptions = productQuestions[j].options;
                        for (var k = 0; k < allOptions.length; k++) {
                            productSpecificQuestions[i].productAttributes[allOptions[k].attributeProperty] = false;
                        }
                        for (var k = 0; k < selectedOptions.length; k++) {
                            productSpecificQuestions[i].productAttributes[selectedOptions[k].attributeProperty] = true;
                        }
                    } else if (productQuestions[j].questionType == "radio") {
                        if (selectedOptions.length > 0) {
                            if (selectedOptions[0].attributeProperty.indexOf('SelectedTerm') > -1) {
                                productSpecificQuestions[i].productAttributes['SelectedTerm'] = selectedOptions[0].option.split(' ')[0];
                            }
                            else if (selectedOptions[0].attributeProperty.indexOf('MachineType') > -1) {
                                if (selectedOptions[0].attributeProperty.indexOf('IsMachineTypeNew') > -1) {
                                    productSpecificQuestions[i].productAttributes['IsMachineTypeNew'] = true;
                                }
                                else {
                                    productSpecificQuestions[i].productAttributes['IsMachineTypeNew'] = false;
                                }
                            }
                            else if (selectedOptions[0].attributeProperty.indexOf('Change') > -1) {
                                if (selectedOptions[0].attributeProperty.indexOf('IsChange') > -1) {
                                    productSpecificQuestions[i].productAttributes['IsChange'] = true;
                                }
                                else {
                                    productSpecificQuestions[i].productAttributes['IsChange'] = false;
                                }
                            }
                            /*else if(selectedOptions[0].attributeProperty.indexOf('CurrentContract')>-1){
                             if(selectedOptions[0].attributeProperty.indexOf('IsCurrentContract')>-1){
                             productSpecificQuestions[i].productAttributes['IsCurrentContract'] = true;
                             }
                             else{
                             productSpecificQuestions[i].productAttributes['IsCurrentContract'] = false;
                             }
                             }*/
                            else if (selectedOptions[0].attributeProperty.indexOf('HPDirect') > -1 || selectedOptions[0].attributeProperty.indexOf('Channel') > -1) {
                                if (selectedOptions[0].attributeProperty.indexOf('HPDirect') > -1) {
                                    productSpecificQuestions[i].productAttributes['ChannelHPDirect'] = true;
                                }
                                else {
                                    productSpecificQuestions[i].productAttributes['ChannelHPDirect'] = false;
                                }
                            }
                            else if (selectedOptions[0].attributeProperty.indexOf('IsFiles') > -1 || selectedOptions[0].attributeProperty.indexOf('IsNotes') > -1) {
                                if (selectedOptions[0].attributeProperty.indexOf('IsFiles') > -1) {
                                    productSpecificQuestions[i].productAttributes['IsFiles'] = true;
                                }
                                else {
                                    productSpecificQuestions[i].productAttributes['IsFiles'] = false;
                                }
                            }
                            else if (selectedOptions[0].attributeProperty.indexOf('IsQuote') > -1) {
                                if (selectedOptions[0].attributeProperty.indexOf('IsIsQuoteContractAS') > -1) {
                                    productSpecificQuestions[i].productAttributes['IsQuoteContract'] = true;
                                }
                                else {
                                    productSpecificQuestions[i].productAttributes['IsQuoteContract'] = false;
                                }
                            }
                        }
                        else {
                            //only currnet contract only answer contains true or false. for other answers objects are stored
                            var allOptions = productQuestions[j].options;
                            if (allOptions.filter(function (e) {
                                    return e.option == "CurrentContract"
                                }).length > 0) {
                                productSpecificQuestions[i].productAttributes['IsCurrentContract'] = productQuestions[j].answer;
                            }
                        }
                    }
                    else if (productQuestions[j].questionType == "date") {
                        if (selectedOptions) {
                            productSpecificQuestions[i].productAttributes[productQuestions[j].attributeProperty] = dateService.formatShortDate(new Date(selectedOptions));
                        }
                    } else {
                        if (selectedOptions) {
                            productSpecificQuestions[i].productAttributes[productQuestions[j].attributeProperty] = selectedOptions.toString();
                        }
                    }
                }
            }

            var allProductSpecificQuestionSks = productSpecificQuestionsCacheService.getProductsRequiringQuestions().map(function (e) {
                return e.EntityTemplateSk;
            });
            var questionsIndex = 0;

            var products = [];
            for (var i = 0; i < request.Products.length; i++) {
                var lookUpListProduct = request.LookupLists.filter(function (e) {
                    return e.EntityTemplateSk == request.Products[i].EntityTemplateSk;
                })[0];
                var product = getNewProduct(i + 1, lookUpListProduct);
                if (allProductSpecificQuestionSks.indexOf(product.EntityTemplateSk) != -1) {
                    productSpecificQuestions[questionsIndex].productAttributes.ProductSk = i + 1;
                    questionsIndex = questionsIndex + 1;

                }
                products.push(product);
            }
            request.Products = products;
            request.ProductAttributes = productSpecificQuestions.map(function (e) {
                return e.productAttributes;
            });


            if (request.isCopy) {
                //If its copy then check whether we need to copy all notes and files
                if (request.isRemoveAllFiles) {
                    request.EntityFiles = [];
                }

                if (request.isRemoveAllNotes) {
                    request.ProductNotes = [];
                    request.RequestNotes = [];
                }
            }

            request.RequestNotes = request.RequestNotes || [];

            if (request.requestInstructions != undefined && request.requestInstructions.length > 0) {
                var requestNotesdata = {
                    "EntityType": "",
                    "NoteSk": 1,
                    "EntitySk": 0,
                    "NoteTypeSk": 1,
                    "NoteText": request.requestInstructions,
                    "ActionSk": null,
                    "IsReportable": false,
                    "IsActive": false,
                    "IsDisplay": false,
                    "IsInternal": false,
                    "EntityTemplateName": "",
                    "EntityName": "Request",
                    "NoteType": "Request Note",
                    "CreateDate": dateService.now(),
                    "UpdateDate": null,
                    "DeleteDate": null,
                    "CreateUserId": localStorage.getItem("LoginId"),
                    "UpdateUserId": "",
                    "DeleteUserId": "",
                    "CreateUserName": localStorage.getItem("FullName"),
                    "Author": localStorage.getItem("FullName")
                };
                request.RequestNotes.push(requestNotesdata);
            }

            delete request.businessSector;
            delete request.RecentEndUsers;
            delete request.RecentProducts;
            delete request.LookupLists;
            delete request.addedEndUsers;
            delete request.notificationEmails;
            delete request.requestInstructions;

            delete request.isSuccessful;
            delete request.responseTime;
            delete request.statusReason;
            delete request.statusCode;
            delete request.responseHeaders;
            delete request.totalTime;

            //exposed variable
            newReqResp = angular.copy(request);
            newReqResp.adHocRecipients = adHocRecipients;

            var invocationData = {
                adapter: 'CreateRequestAdapter',
                procedure: 'submitRequest',
                parameters: [authCredentials.cookie, authCredentials.sessionId, request, adHocRecipients, ccRecipients]
            };
            var options = {
                onSuccess: success,
                onFailure: failure,
                invocationContext: {}
            };

            function success(result) {
                console.log('newRequestService: Request Create Successful', result);
                submitResp = result;
                addCookieValues(result.invocationResult.cookie);
                if (result.invocationResult.isSuccessful) {
                    if (result.invocationResult.ReturnResult.ResultMessage == "Completed Successfully" || result.invocationResult.ReturnResult.ResultMessage == "An error occurred retrieving the Quote List from Q2O") {
                        defered.resolve();
                    } else {
                        defered.reject();
                    }
                } else {
                    defered.reject();
                }
                loadingOverlayService.hide();
            }

            function failure(error) {
                submitResp = error;
                defered.reject();
                loadingOverlayService.hide();
            }

            loadingOverlayService.show();
            console.log('parameters sent to submitRequest are :');
            console.log([authCredentials.cookie, authCredentials.sessionId, request, adHocRecipients, ccRecipients]);
            WL.Client.invokeProcedure(invocationData, options);
            return defered.promise;
        }

        /** Submits the Revised Request with all the data added -> Populating product Specific Questions, adding entire product Data of added Products,
         *    Properly updating the Notifications List etc.,
         *    @param reviseActionName - reviseActionName
         *   @param reviseAction - reviseAction
         *   @param reviseNotes - reviseNotes
         */

        function submitReviseRequest(reviseActionName, reviseAction, reviseNotes) {
            var reviseRequestTemplate = {
                "RequestNumber": 7449577,
                "ProductCount": 1,
                "Action": {
                    "EntityType": "Product",
                    "EntitySk": 2459562,
                    "EventName": "Revise Quote",
                    "ActionSk": 0,
                    "ActionName": "Revise Name",
                    "ActionTypeSk": 43,
                    "AlertSk": null,
                    "RevisedFromEntitySk": 2459562,
                    "RevisedReasonTypeSk": 2,
                    "CurrentHoldReasonTypeSk": null,
                    "CurrentCancelReasonTypeSk": null,
                    "CurrentAssignId": null,
                    "CurrentAssignFullName": null,
                    "ConfigComplexityLevel": null,
                    "OutputsNumber": 0,
                    "PriorityLevel": null,
                    "CustomerPurchaseOrderNumber": null,
                    "POReleaseNumber": null,
                    "QuoteNumber": 119529412,
                    "QuoteRevNumber": 1,
                    "ReviseConfigFileId": null,
                    "ReviseConfigFileName": null,
                    "ProductList": null,
                    "ActionTypeName": null,
                    "IsInternal": false,
                    "ActionGroup": null,
                    "IsQuote": false,
                    "IsOrder": false,
                    "IsShowInCustomerSummary": false,
                    "RevisedReasonTypeCode": null,
                    "HoldReasonType": null,
                    "CancelReasonType": null,
                    "RevisedReasonType": null,
                    "WorkflowStatus": null,
                    "WorkflowId": null,
                    "CreateDate": "",
                    "UpdateDate": "",
                    "DeleteDate": null,
                    "CreateUserId": null,
                    "UpdateUserId": null,
                    "DeleteUserId": null
                },
                "Products": [],
                "Notification": {
                    "adHocRecipients": [],
                    "ccRecipients": [],
                    "fileList": [],
                    "forceSend": false,
                    "isNoteInternal": false,
                    "isNoteReportable": false,
                    "noteText": "Test Noteesss",
                    "recipients": [],
                    "requestSk": 2459561,
                    "shouldSend": false,
                    "subject": ""
                },
                "EntityFiles": []
            };

            var request = getRequest();

            reviseRequestTemplate.ccRecipients = (request.notificationEmails || []).filter(function (contact) {
                return angular.isObject(contact);
            }).map(function (item) {
                return item.EmailAddress
            });
            console.log('ccRecipients: ', reviseRequestTemplate.ccRecipients);

            reviseRequestTemplate.adHocRecipients = (request.notificationEmails || []).filter(function (contact) {
                return !angular.isObject(contact);
            });
            console.log('adHocRecipients: ', reviseRequestTemplate.adHocRecipients);

            reviseRequestTemplate.recipients = (request.notificationEmails || []).filter(function (e) {
                if (angular.isObject(e))
                    return e.IsNotifyAssigned == false && e.IsNotifySuggested == true;
                else
                    return false;
            });


            var defered = $q.defer();
            var authCredentials = loginCacheService.getLoginToken();

            reviseRequestTemplate.ProductCount = newRequestFactory.selectedRequestQuote.products ? newRequestFactory.selectedRequestQuote.products.length : 0;

            //reviseRequestTemplate.RequestSk = newRequestFactory.selectedReviseQuote.requestSk;
            //reviseRequestTemplate.RequestNumber = newRequestFactory.selectedRequestQuote.requestNumber;

            reviseRequestTemplate.RequestSk = localStorage.RequestRevisionSK;
            reviseRequestTemplate.RequestNumber = newRequestFactory.selectedRequestQuote.requestNumber;


            if (newRequestFactory.isReviseConfig) {
                //this is a config revise
                reviseRequestTemplate.Action.ActionTypeSk = 39;
                reviseRequestTemplate.Action.EventName = "Revise Config";
            } else {
                //this is a quote revise
                reviseRequestTemplate.Action.ActionTypeSk = 43;
                reviseRequestTemplate.Action.EventName = "Revise Quote";
            }

            reviseRequestTemplate.Action.EntitySk = newRequestFactory.selectedReviseProduct.ProductSk;
            reviseRequestTemplate.Action.RevisedFromEntitySk = newRequestFactory.selectedReviseProduct.ProductSk;
            reviseRequestTemplate.Action.RevisedReasonTypeSk = parseInt(request.reviseAction);

            //only for revise quote
            reviseRequestTemplate.Action.QuoteNumber = newRequestFactory.selectedReviseQuote ? newRequestFactory.selectedReviseQuote.quoteNumber : null;
            reviseRequestTemplate.Action.QuoteRevNumber = newRequestFactory.selectedReviseQuote ? newRequestFactory.selectedReviseQuote.quoteRevisionNumber : null;


            //reviseRequestTemplate.Notification.requestSk = newRequestFactory.selectedReviseQuote.requestSk;
            reviseRequestTemplate.Notification.requestSk = newRequestFactory.selectedRequestQuote.RequestRevisionSK;

            reviseRequestTemplate.Notification.noteText = request.requestInstructions;
            reviseRequestTemplate.Action.ActionName = request.reviseQuoteName;

            reviseRequestTemplate.Notification.recipients = request.selectedNotificationEmails;


            //product specific questions
            var productSpecificQuestions = newRequestFactory.productSpecificQuestions;
            for (var i = 0; i < (productSpecificQuestions || []).length; i++) {
                var productQuestions = productSpecificQuestions[i].questions;
                for (var j = 0; j < productQuestions.length; j++) {
                    var selectedOptions = productQuestions[j].answer;
                    if (productQuestions[j].questionType == "multiSelect") {
                        var allOptions = productQuestions[j].options;
                        for (var k = 0; k < allOptions.length; k++) {
                            productSpecificQuestions[i].productAttributes[allOptions[k].attributeProperty] = false;
                        }
                        for (var k = 0; k < selectedOptions.length; k++) {
                            productSpecificQuestions[i].productAttributes[selectedOptions[k].attributeProperty] = true;
                        }
                    } else if (productQuestions[j].questionType == "radio") {
                        if (selectedOptions.length > 0) {
                            if (selectedOptions[0].attributeProperty.indexOf('SelectedTerm') > -1) {
                                productSpecificQuestions[i].productAttributes['SelectedTerm'] = selectedOptions[0].option.split(' ')[0];
                            }
                            else if (selectedOptions[0].attributeProperty.indexOf('MachineType') > -1) {
                                if (selectedOptions[0].attributeProperty.indexOf('IsMachineTypeNew') > -1) {
                                    productSpecificQuestions[i].productAttributes['IsMachineTypeNew'] = true;
                                }
                                else {
                                    productSpecificQuestions[i].productAttributes['IsMachineTypeNew'] = false;
                                }
                            }
                            else if (selectedOptions[0].attributeProperty.indexOf('Change') > -1) {
                                if (selectedOptions[0].attributeProperty.indexOf('IsChange') > -1) {
                                    productSpecificQuestions[i].productAttributes['IsChange'] = true;
                                }
                                else {
                                    productSpecificQuestions[i].productAttributes['IsChange'] = false;
                                }
                            }
                            /*else if(selectedOptions[0].attributeProperty.indexOf('CurrentContract')>-1){
                             if(selectedOptions[0].attributeProperty.indexOf('IsCurrentContract')>-1){
                             productSpecificQuestions[i].productAttributes['IsCurrentContract'] = true;
                             }
                             else{
                             productSpecificQuestions[i].productAttributes['IsCurrentContract'] = false;
                             }
                             }*/
                            else if (selectedOptions[0].attributeProperty.indexOf('HPDirect') > -1 || selectedOptions[0].attributeProperty.indexOf('Channel') > -1) {
                                if (selectedOptions[0].attributeProperty.indexOf('HPDirect') > -1) {
                                    productSpecificQuestions[i].productAttributes['ChannelHPDirect'] = true;
                                }
                                else {
                                    productSpecificQuestions[i].productAttributes['ChannelHPDirect'] = false;
                                }
                            }
                            else if (selectedOptions[0].attributeProperty.indexOf('IsFiles') > -1 || selectedOptions[0].attributeProperty.indexOf('IsNotes') > -1) {
                                if (selectedOptions[0].attributeProperty.indexOf('IsFiles') > -1) {
                                    productSpecificQuestions[i].productAttributes['IsFiles'] = true;
                                }
                                else {
                                    productSpecificQuestions[i].productAttributes['IsFiles'] = false;
                                }
                            }
                            else if (selectedOptions[0].attributeProperty.indexOf('IsQuote') > -1) {
                                if (selectedOptions[0].attributeProperty.indexOf('IsIsQuoteContractAS') > -1) {
                                    productSpecificQuestions[i].productAttributes['IsQuoteContract'] = true;
                                }
                                else {
                                    productSpecificQuestions[i].productAttributes['IsQuoteContract'] = false;
                                }
                            }
                        }
                        else {
                            //only currnet contract only answer contains true or false. for other answers objects are stored
                            var allOptions = productQuestions[j].options;
                            if (allOptions.filter(function (e) {
                                    return e.option == "CurrentContract"
                                }).length > 0) {
                                productSpecificQuestions[i].productAttributes['IsCurrentContract'] = productQuestions[j].answer;
                            }
                        }
                    }
                    else if (productQuestions[j].questionType == "date") {
                        if (selectedOptions) {
                            productSpecificQuestions[i].productAttributes[productQuestions[j].attributeProperty] = dateService.formatShortDate(new Date(selectedOptions));
                        }
                    } else {
                        if (selectedOptions) {
                            productSpecificQuestions[i].productAttributes[productQuestions[j].attributeProperty] = selectedOptions.toString();
                        }
                    }
                }
            }

            var allProductSpecificQuestionSks = productSpecificQuestionsCacheService.getProductsRequiringQuestions().map(function (e) {
                return e.EntityTemplateSk;
            });
            var questionsIndex = 0;

            var products = [];
            for (var i = 0; i < request.Products.length; i++) {
                var lookUpListProduct = request.LookupLists.filter(function (e) {
                    return e.EntityTemplateSk == request.Products[i].EntityTemplateSk;
                })[0];
                var product = getNewProduct(i + 1, lookUpListProduct);
                if (allProductSpecificQuestionSks.indexOf(product.EntityTemplateSk) != -1) {
                    productSpecificQuestions[questionsIndex].productAttributes.ProductSk = i + 1;
                    questionsIndex = questionsIndex + 1;

                }
                products.push(product);
            }
            reviseRequestTemplate.Products = products;
            reviseRequestTemplate.ProductAttributes = productSpecificQuestions.map(function (e) {
                return e.productAttributes;
            });

            var invocationData = {
                adapter: 'ReviseRequestAdapter',
                procedure: 'reviseRequest',
                parameters: [authCredentials.cookie, authCredentials.sessionId, reviseRequestTemplate]
            };
            var options = {
                onSuccess: success,
                onFailure: failure,
                invocationContext: {}
            };

            function success(result) {
                console.log('newRequestService: Revise Successful: ', result);
                loadingOverlayService.hide();
                addCookieValues(result.invocationResult.cookie);
                submitResp = result;
                if (result.invocationResult.isSuccessful) {
                    if (result.invocationResult.ReturnResult.ResultMessage == "Completed Successfully" || result.invocationResult.ReturnResult.ResultMessage == "An error occurred retrieving the Quote List from Q2O") {
                        defered.resolve();
                    } else {
                        defered.reject();
                    }
                } else {
                    defered.reject();
                }
            }

            function failure(error) {
                console.log("newRequestFactory: Error revising request", error);
                defered.reject();
                loadingOverlayService.hide();
            }

            loadingOverlayService.show();
            console.log('parameters passed : ', [authCredentials.cookie, authCredentials.sessionId, reviseRequestTemplate]);
            WL.Client.invokeProcedure(invocationData, options);

            return defered.promise;
        }

        /** Returns Matched EndUsers based on the provided Search Term
         *    @param searchTerm - searchTerm to get the matched end users
         */
        function getMatchedEndUsers(searchTerm) {
            var defered = $q.defer();
            var authCredentials = loginCacheService.getLoginToken();
            var invocationData = {
                adapter: 'CreateRequestAdapter',
                procedure: 'getAllUsers',
                parameters: [authCredentials.cookie, authCredentials.sessionId, searchTerm, localStorage.getItem("PartnerId")]
            };
            var options = {
                onSuccess: success,
                onFailure: failure,
                invocationContext: {}
            };

            function success(result) {
                newReqResp = result;
                addCookieValues(result.invocationResult.cookie);
                defered.resolve(result.invocationResult.data);
                loadingOverlayService.hide();
            }

            function failure() {
                //defered.resolve([]);
                defered.reject();
                loadingOverlayService.hide();
            }

            loadingOverlayService.show();
            WL.Client.invokeProcedure(invocationData, options);
            return defered.promise;
        }

        /** Updates the Product Specific Questions */
        function updateProductSpecificQuestions() {
            //get selected products
            var selectedProducts = newRequestFactory.request.Products || [];
            //update questions required flag

            newRequestFactory.areQuestionsRequired = productSpecificQuestionsCacheService.areQuestionsRequired(selectedProducts);
            //get product specific questions
            //selectedProducts = selectedProducts.map(function(item){ return item.EntityTemplateSk; });

            var allProductSpecificQuestions = productSpecificQuestionsCacheService.getProductsRequiringQuestions();

            var allQuesSks = allProductSpecificQuestions.map(function (item) {
                return item.EntityTemplateSk;
            });

            var previousAddedQuestionsSks = newRequestFactory.productSpecificQuestions.map(function (e) {
                return e.EntityTemplateSk;
            });
            var requiredQuestions = [];
            for (var i = 0; i < selectedProducts.length; i++) {
                var questionsIndexTemp = allQuesSks.indexOf(selectedProducts[i].EntityTemplateSk);
                if (questionsIndexTemp != -1) {
                    var prodIndexInpreviousAddedQuestions = previousAddedQuestionsSks.indexOf(selectedProducts[i].EntityTemplateSk);
                    if (prodIndexInpreviousAddedQuestions != -1) {
                        requiredQuestions.push(angular.copy(newRequestFactory.productSpecificQuestions[prodIndexInpreviousAddedQuestions]));
                    }
                    else {
                        requiredQuestions.push(angular.copy(allProductSpecificQuestions[questionsIndexTemp]));
                    }
                }
            }
            /*var requiredQuestions = allProductSpecificQuestions.filter(function(item){
             return selectedProducts.indexOf(item.EntityTemplateSk) != -1;
             });*/
            newRequestFactory.productSpecificQuestions = requiredQuestions;
        }

        /** Adds Product Specific Questions of the provided Product
         *    @param product - product to which product specific questions to be added
         */
        function addProductSpecificQuestions(product) {
            console.log('in addProductSpecificQuestions');
            console.log(product);
            var allProductSpecificQuestions = productSpecificQuestionsCacheService.getProductsRequiringQuestions();
            var allQuesSks = allProductSpecificQuestions.map(function (item) {
                return item.EntityTemplateSk;
            });
            var questionsIndexTemp = allQuesSks.indexOf(product.EntityTemplateSk);
            if (questionsIndexTemp != -1) {
                var tempQuestions = angular.copy(allProductSpecificQuestions[questionsIndexTemp]);
                tempQuestions.productIndexCount = product.productIndexCount;
                newRequestFactory.productSpecificQuestions.push(tempQuestions);
            }
        }

        /** Removes Product Specific Questions of the provided Product
         *    @param product - product to which product specific questions to be removed
         */
        function removeProductSpecificQuestions(product) {
            console.log('in removeProductSpecificQuestions');
            console.log(product);
            var allProdQuesSks = newRequestFactory.productSpecificQuestions.map(function (item) {
                return item.EntityTemplateSk;
            });
            var questionsIndexTemp = allProdQuesSks.indexOf(product.EntityTemplateSk);
            if (questionsIndexTemp != -1) {
                for (var i = newRequestFactory.productSpecificQuestions.length - 1; i >= 0; i--) {
                    if (newRequestFactory.productSpecificQuestions[i].EntityTemplateSk == product.EntityTemplateSk && newRequestFactory.productSpecificQuestions[i].productIndexCount == product.productIndexCount) {
                        newRequestFactory.productSpecificQuestions.splice(i, 1);
                        return;
                    }
                }
                ;
            }
        }

        /** Gets Disclaimer Content */
        function getDisclaimer() {
            var defered = $q.defer();
            var authCredentials = loginCacheService.getLoginToken();
            var products = getRequest().Products;

            var invocationData = {
                adapter: 'CreateRequestAdapter',
                procedure: 'getDisclaimers',
                parameters: [authCredentials.cookie, authCredentials.sessionId]
            };

            var options = {
                onSuccess: success,
                onFailure: failure,
                invocationContext: {}
            };

            function success(result) {
                addCookieValues(result.invocationResult.cookie);
                var productSks = products.map(function (e) {
                    return e.EntityTemplateSk;
                });
                var disclaimers = result.invocationResult.ProductDisclaimers.ProductDisclaimers;
                var requiredDisclaimers = disclaimers.filter(function (disclaimer) {
                    return productSks.indexOf(disclaimer.EntityTemplateSk) != -1;
                });
                newRequestFactory.disclaimers = angular.copy(requiredDisclaimers);
                defered.resolve(requiredDisclaimers);
                loadingOverlayService.hide();
            }

            function failure() {
                //defered.resolve([]);
                defered.reject();
                loadingOverlayService.hide();
            }

            loadingOverlayService.show();
            WL.Client.invokeProcedure(invocationData, options);
            return defered.promise;
        }

        /** Resets New Request Data */
        function resetNewRequest() {
            newRequestFactory.setRequest(undefined);
            newRequestFactory.isSubmitButtonClicked = false;
            newRequestFactory.questionsSaveClicked = false;
            newRequestFactory.temporaryNotificationEmails = [];
            newRequestFactory.temporarySelectedContacts = [];
            newRequestFactory.removedProductIndexes = {};
            newRequestFactory.productSpecificQuestions = [];
            newRequestFactory.selectedReviseQuote = undefined;
            newRequestFactory.selectedReviseProduct = undefined;
            newRequestFactory.selectedRequestQuote = undefined;
            newRequestFactory.selectedReviseConfig = undefined;
            newRequestFactory.selectedReviseTab = 1;
            newRequestFactory.isReviseConfig = false;
        }

        return newRequestFactory;
    }
})();

var quoteDetailResp;
/**
*  Quote Detail Service
*
*  Provides methods for getting Quote Detail Data, editing Request Name, editing End User and Adding Notes
*/
(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
	.factory('quoteDetailFactory', quoteDetailFactory);
	quoteDetailFactory.$inject = ['$q', 'loginCacheService', 'quoteDetailCacheService', 'loadingOverlayService'];
	
	function quoteDetailFactory($q, loginCacheService,quoteDetailCacheService,loadingOverlayService){
		
		var quoteDetailFactory={
			loadQuoteDetailData : loadQuoteDetailData,
			getQuoteLineData : getQuoteLineData,
			editRequestName: editRequestName,
			addNote: addNote,
			editEndUser : editEndUser
		};
		
		/** Loads Quote Detail Data for the provided requestRevisionSK 
		* 	@param requestRevisionSK - requestRevisionSK of Request to get the details
		*/
		function loadQuoteDetailData(requestRevisionSK){
			var defered = $q.defer();
			var tryCount = 0;
			function getQuoteDetailSuccessCB(response){
				quoteDetailResp = response;
				if(response.invocationResult.cookie != undefined)
					addCookieValues(response.invocationResult.cookie);
				if(response.invocationResult.isSuccessful == true){
					if(response.invocationResult.data.statusCode != 200){
						if(response.invocationResult.data.statusCode == 403){
							loadingOverlayService.hide();
							defered.reject(response.invocationResult.data.message);
						}else{
							if(tryCount < 3){
								tryCount = tryCount + 1;
								WL.Client.invokeProcedure(invocationData, options);							
							}else{
								loadingOverlayService.hide();
								defered.reject('Service unavailable');
							}
						}
					}else{
						loadingOverlayService.hide();
						console.log('response.invocationResult.data.statusCode == 200');
						/*quoteDetailCacheService.updateQuoteDetail(response.invocationResult.data, requestRevisionSK)
						.then(function(){
							console.log('quoteDetailCacheService.updateQuoteDetail success method');
							loadingOverlayService.hide();
							defered.resolve(response.invocationResult.data);
						}, function(){
							console.log('quoteDetailCacheService.updateQuoteDetail failure method');
							loadingOverlayService.hide();
							defered.reject('Offline error');
						});*/
						defered.resolve(response.invocationResult.data);
					}
				}else{
					loadingOverlayService.hide();
					defered.reject("Service unavailable");
				}
			}
			function getQuoteDetailFailureCB(error){
				loadingOverlayService.hide();
				defered.reject("no network");
			};
			
			var authCredentials = loginCacheService.getLoginToken();
			
			var invocationData = {
			    adapter : 'QuotesAdapter',
			    procedure : 'getQuotesDetails',
			    parameters : [authCredentials.cookie,authCredentials.sessionId, requestRevisionSK, true]
			};
			var options = {
			    onSuccess : getQuoteDetailSuccessCB,
			    onFailure : getQuoteDetailFailureCB,
			    invocationContext: {}
			};
			
			loadingOverlayService.show();
			WL.Client.invokeProcedure(invocationData, options);
			return defered.promise;
		};
		
		/** Gets The Quote Line Data  */
		function getQuoteLineData(quoteNumber, quoteRevisionNumber){
			var defered = $q.defer();
			var authCredentials = loginCacheService.getLoginToken();
			
			var invocationData = {
			    adapter : 'QuotesAdapter',
			    procedure : 'getLineItems',
			    parameters : [authCredentials.cookie,authCredentials.sessionId, quoteNumber, quoteRevisionNumber]
			};
			
			function getLineDataSuccessCB(response){
				if(response.invocationResult.cookie != undefined)
					addCookieValues(response.invocationResult.cookie);
				loadingOverlayService.hide();
				if(response.invocationResult.isSuccessful == true){
					defered.resolve(response.invocationResult.lineItems);
				}else{
					defered.reject("service error");
				}
			}
			
			function getLineDataFailureCB(error){
				loadingOverlayService.hide();
				defered.reject();
			}
			
			var options = {
			    onSuccess : getLineDataSuccessCB,
			    onFailure : getLineDataFailureCB,
			    invocationContext: {}
			};
			
			loadingOverlayService.show();
			WL.Client.invokeProcedure(invocationData, options);
			return defered.promise;
		};
		
		/** Edits Request Name for provided requestSk 
		*	@param requestSk - requestSk of Request
		*	@param newRequestName - newRequestName of Request
		*/
		function editRequestName(requestSk, newRequestName){
			var defered = $q.defer();
			//alert ("in service. sk: " + requestSk + ". New requestnName: " + newRequestName);
			var authCredentials = loginCacheService.getLoginToken();
			
			var invocationData = {
			    adapter : 'QuotesAdapter',
			    procedure : 'editRequestName',
			    parameters : [authCredentials.cookie,authCredentials.sessionId, requestSk, newRequestName]
			};
			
			function editRequestNameSuccessCB(response){
				addCookieValues(response.invocationResult.cookie);
				loadingOverlayService.hide();
				//alert("in success");
				if(response.invocationResult.isSuccessful == true){
					//defered.resolve(response.invocationResult.lineItems);
					defered.resolve(response);
				}else{
					defered.reject("service error");
				}
			}
			
			function editRequestNameFailureCB(error){
				loadingOverlayService.hide();
				//alert("in failure: " + JSON.stringify(error));
				defered.reject();
			}
			
			var options = {
			    onSuccess : editRequestNameSuccessCB,
			    onFailure : editRequestNameFailureCB,
			    invocationContext: {}
			};
			
			loadingOverlayService.show();
			WL.Client.invokeProcedure(invocationData, options);
			return defered.promise;
		};
		
		/** Add Notes for Request 
		*	@param requestSk - requestSk of Request
		*	@param noteText - noteText of note to be added to Request
		*	@param recipients - recipients for which notification should be sent
		*	@param adHocRecipients - adHocRecipients 
		*/
		function addNote(requestSk, noteText, recipients, adHocRecipients){
			var defered = $q.defer();
			//alert ("in addnote service. sk: " + requestSk + ". New note: " + noteText);
			var authCredentials = loginCacheService.getLoginToken();
			
			var invocationData = {
			    adapter : 'QuotesAdapter',
			    procedure : 'addNote',
			    parameters : [authCredentials.cookie,authCredentials.sessionId, requestSk, noteText, JSON.stringify(recipients), JSON.stringify(adHocRecipients)]
			};
			
			function addNoteSuccessCB(response){
				addCookieValues(response.invocationResult.cookie);
				loadingOverlayService.hide();
				if(response.invocationResult.isSuccessful == true){
					defered.resolve(response);
				}else{
					defered.reject("service error");
				}
			}
			
			function addNoteFailureCB(error){
				loadingOverlayService.hide();
				//alert("in failure: " + JSON.stringify(error));
				defered.reject();
			}
			
			var options = {
			    onSuccess : addNoteSuccessCB,
			    onFailure : addNoteFailureCB,
			    invocationContext: {}
			};
			
			loadingOverlayService.show();
			WL.Client.invokeProcedure(invocationData, options);
			return defered.promise;
		}

		/** Edits EndUser of the Request 
		*	requestJson - data containing new end user
		*	requestSk - requestSk of Request
		*/
		function editEndUser(requestJson,requestSk){
			//requestJson=JSON.stringify(requestJson);
			var defered = $q.defer();
			var authCredentials = loginCacheService.getLoginToken();
			
			var invocationData = {
			    adapter : 'QuotesAdapter',
			    procedure : 'editEndUser',
			    parameters : [authCredentials.cookie,authCredentials.sessionId, JSON.stringify(requestJson), requestSk]
			};
			
			function editEndUserSuccessCB(response){
				addCookieValues(response.invocationResult.cookie);
				loadingOverlayService.hide();
				//alert("in success");
				if(response.invocationResult.isSuccessful == true){
					//defered.resolve(response.invocationResult.lineItems);
					defered.resolve(response);
				}else{
					defered.reject("service error");
				}
			}
			
			function editEndUserFailureCB(error){
				loadingOverlayService.hide();
				defered.reject();
			}
			
			var options = {
			    onSuccess : editEndUserSuccessCB,
			    onFailure : editEndUserFailureCB,
			    invocationContext: {}
			};
			
			loadingOverlayService.show();
			WL.Client.invokeProcedure(invocationData, options);
			return defered.promise;
			
		}
		return quoteDetailFactory;
	}
})();
var quotesResp;
/**
 *  Quotes Service
 *
 *  Provides methods for getting Quotes Data
 */
(function () {
    'use strict';

    angular.module('ccMobile.requests')
        .factory('quotesFactory', quotesFactory);
    quotesFactory.$inject = ['$q', 'loginCacheService', 'quoteListCacheService', 'loadingOverlayService'];

    function quotesFactory($q, loginCacheService, quoteListCacheService, loadingOverlayService) {

        var quotesFactory = {
            loadQuotesData: loadQuotesData
        };

        /** Loads Quotes Data */
        function loadQuotesData() {
            console.log('quotesFactory: loadQuotesData');

            var defered = $q.defer();

            var tryCount = 0;

            function getQuotesSuccessMethod(response) {
                if (response.invocationResult.cookie != undefined)
                    addCookieValues(response.invocationResult.cookie);
                if (response.invocationResult.isSuccessful == true) {
                    if (response.invocationResult.sessionExpired == true) {
                        loadingOverlayService.hide();
                        defered.reject("sessionExpired");
                    } else {
                        if (response.invocationResult.requests != undefined) {
                            quoteListCacheService.updateQuotes(response.invocationResult.requests)
                                .then(function () {
                                    loadingOverlayService.hide();
                                    defered.resolve();
                                }, function () {
                                    loadingOverlayService.hide();
                                    defered.reject();
                                });
                        } else {
                            if (tryCount < 3) {
                                tryCount = tryCount + 1;
                                WL.Client.invokeProcedure(invocationData, options);
                            } else {
                                loadingOverlayService.hide();
                                defered.reject();
                            }
                        }
                    }
                } else {
                    loadingOverlayService.hide();
                    defered.reject("service unavailable");
                }
            }


            function getQuotesFailureMethod(error) {
                loadingOverlayService.hide();
                defered.reject(error);
            }

            var authCredentials = loginCacheService.getLoginToken();

            var invocationData = {
                adapter: 'QuotesAdapter',
                procedure: 'getQuotesList',
                parameters: [authCredentials.cookie, authCredentials.sessionId, localStorage.getItem("IsInternal")]
            };
            var options = {
                onSuccess: getQuotesSuccessMethod,
                onFailure: getQuotesFailureMethod,
                invocationContext: {}
            };
            console.log('quotesFactory: parameters: ', invocationData.parameters);
            loadingOverlayService.show();
            WL.Client.invokeProcedure(invocationData, options);
            return defered.promise;
        }

        return quotesFactory;
    }
})();

var newScope, newFact;
(function(){
	'use strict';
	
	reviseQuoteController.$inject = ['$scope', '$rootScope', 'newRequestFactory', '$state', '$timeout'];
	angular.module('ccMobile.requests')
		.controller('reviseQuoteController', reviseQuoteController);


	/**
	 * function that controls the revise quote functionality
	 */
	function reviseQuoteController($scope, $rootScope, newRequestFactory, $state, $timeout){
		
		$scope.submitReviseRequest = submitReviseRequest;
		$scope.isSubmitButtonClicked=newRequestFactory.isSubmitButtonClicked;		
		$scope.refreshRequest=refreshRequest;		
		$scope.showInstructionsInView=showInstructionsInView;
		$scope.blurElementWithId=blurElementWithId;
		$scope.handleBackButton = handleBackButton;
		$scope.cancelRevise = cancelRevise;


		$scope.isReviseConfig = newRequestFactory.isReviseConfig;
		$scope.title = $scope.isReviseConfig? 'Revise Config' : 'Revise Quote';
		$scope.selectedReviseConfig = newRequestFactory.selectedReviseConfig;

		$scope.selectedReviseQuote = newRequestFactory.selectedReviseQuote;

		$scope.productSpecificQuestions = newRequestFactory.productSpecificQuestions || [];

		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});

		if(newRequestFactory.getRequest() == undefined){
			newRequestFactory.getNewRequest("modify")
			.then(function(request){

				$scope.request = request;
				$scope.notificationListCount=0;
				$scope.notificationListString="Please select notifications";				
				$scope.productsListString="Please Specify a Product";
				$scope.disableSubmitButton=true;


				if($scope.isReviseConfig){
					//$scope.request.reviseQuoteName = 'Revise Config';	
				} else if($scope.selectedReviseQuote) {					
					$scope.request.reviseQuoteName = $scope.selectedReviseQuote.quoteNumber + '-' + $scope.selectedReviseQuote.quoteRevisionNumber;
				}
				validateForm();			
			},function(){
				//Error Callback
				console.log("reviseQuoteController: error retrieving newRequest");
				WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
				  text : "OK",
				  handler: function(){
				  	handleBackButton();
				  }
				}]);
			});
		} else {
			$scope.request = newRequestFactory.getRequest();
			if($scope.isReviseConfig){
				//$scope.request.reviseQuoteName = 'Revise Config';	
			} else if($scope.selectedReviseQuote) {					
				$scope.request.reviseQuoteName = $scope.selectedReviseQuote.quoteNumber + '-' + $scope.selectedReviseQuote.quoteRevisionNumber;
			}
			validateForm();
		}


		/**
		 * function to submit the revise request
		 * @param revise action name 
		 * @param reviseAction - Action to be performed
		 * @param revieseNotes - Notes
		 */
		function submitReviseRequest(reviseActionName,reviseAction,reviseNotes){
			console.log("going to submit request", newRequestFactory.request,reviseActionName,reviseAction,reviseNotes);

			$scope.isSubmitButtonClicked=true;
			newRequestFactory.isSubmitButtonClicked=true;

			
			validateForm();
			if(!$scope.disableSubmitButton){
				console.log('reviseQuoteController: Form is valid going to submit');

				
				newRequestFactory.submitReviseRequest(reviseActionName,reviseAction,reviseNotes)
					.then(function(){
							resetFields();
							$state.go('^.reviseSubmissionSuccessful');
					}, function(error){
						console.log('reviseQuoteController: Error revising quote', error);
						WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
							  text : "OK",
							  handler: function(){
							  	resetFields();
							  	$state.go('^.quotes');
							  }
							}]);
					});
			}

		}

		function showInstructionsInView(){
			console.log('in textarea focus method');
			$timeout(function() { 
				document.getElementsByClassName('instructions')[0].scrollIntoView(true);
			},1000);
		}

		/**
		 * function to blur html element
		 * @param id
		 */
		function blurElementWithId(id){
			$timeout(function() { 
				document.getElementById(id).blur();
			});
		}

		

		/**
		 * function to refresh the request page
		 */
		function refreshRequest(){
			console.log('in refreshRequest method');
			newRequestFactory.setRequest($scope.request);
			validateForm();
		}


		/**
		 * function to validate the revise request form
		 */
		function validateForm(){
			console.log('in validateForm method');
			$scope.disableSubmitButton=false;
			console.log('checking notifications');

			if(!(($scope.request.notificationEmails==undefined) || ($scope.request.notificationEmails.length==0))){
				
				$scope.correctlyFilledNotificationsList=true;
				var selectedAddedEmails=$scope.request.notificationEmails.filter(function(e){ return !angular.isObject(e) }).map(function(e){ return e})
				$scope.notificationListCount=selectedAddedEmails.length;
				$scope.notificationListString=selectedAddedEmails.join(', ');

				var selectedReceivedEmails=$scope.request.notificationEmails.filter(function(e){ return angular.isObject(e) }).map(function(e){ return e.EmailAddress});
				if(selectedReceivedEmails.length!=0 && selectedAddedEmails.length!=0)
					$scope.notificationListString=$scope.notificationListString+', ';
				$scope.notificationListCount=$scope.notificationListCount+selectedReceivedEmails.length;
				$scope.notificationListString=$scope.notificationListString+selectedReceivedEmails.join(', ');


				//Set the notification email list
				$scope.request.selectedNotificationEmails = selectedAddedEmails.concat(selectedReceivedEmails);
			}
			else{

				//Set the notification email list
				$scope.request.selectedNotificationEmails = [];

				$scope.notificationListCount=0;
				$scope.notificationListString="Select People to Notify";
				console.log('no notifications list');				
			}


			console.log('checking products');
			if(!(($scope.request.Products == undefined) || ($scope.request.Products.length==0))){
				$scope.correctlyFilledProducts=true;
				$scope.productListCount = $scope.request.Products.length;
				$scope.productsListString=$scope.request.Products.map(function(item){
					if(item.productIndexCount>1)
						return item.EntityTemplateName+" "+item.productIndexCount;
					else
						return item.EntityTemplateName;
				}).join(', ');
			} else {
				$scope.productListCount = 0;
				$scope.productsListString="Select Products to Add";
				console.log('no products list');
			}
			
			console.log('checking validateProductOptions');
			(function(){
				var products = newRequestFactory.productSpecificQuestions || [];
				var prodCount=0;
				for (var i = products.length - 1; i >= 0; i--) {
					var questions=products[i].questions || [];
					var j = questions.length - 1
					for (; j >= 0; j--) {
						if((questions[j].answer == undefined || questions[j].answer == null || questions[j].answer.length==0) && questions[j].isMandatory){
							console.log('no answer Specified');
							break;
						}
					};
					console.log(j);
					if(j!=-1){
						prodCount=prodCount+1;
					}
					console.log('prodCount :'+prodCount);
				};
				if(prodCount >1){
					$scope.productOptionsString=prodCount+' Products Require More Info';
				}
				else if(prodCount == 1){
					$scope.productOptionsString=prodCount+' Product Requires More Info';
				}
				else{
					if(products.length>1)
						$scope.productOptionsString=products.length+' Products Ready';
					else
						$scope.productOptionsString=products.length+' Product Ready';
				}
			})();

			if(validateProductOptions()){
				console.log('productOptions is valid');
				$scope.correctlyFilledProductOptions=true;
			} else {
				console.log('productOptions is Invalid');
				$scope.disableSubmitButton=true;
				if($scope.isSubmitButtonClicked){
					$scope.productOptionsError=true;
				}
			}


			if($scope.request.reviseQuoteName==undefined || $scope.request.reviseQuoteName==""){
				if($scope.isSubmitButtonClicked){
					$scope.reviseQuoteNameError=true;
				}
				$scope.disableSubmitButton=true;
			} else {
				$scope.reviseQuoteNameError=false;
			}

			if($scope.request.reviseAction == undefined || $scope.request.reviseAction == ""){
				if($scope.isSubmitButtonClicked){
					$scope.reviseActionError=true;
				}
				$scope.disableSubmitButton=true;
			} else {
				$scope.reviseActionError=false;
			}

			if($scope.request.requestInstructions==undefined || $scope.request.requestInstructions=="" || !testAlphaNumeric($scope.request.requestInstructions)){
				if($scope.isSubmitButtonClicked){
					console.log('addRequestInstructionsError found');
					$scope.requestInstructionsError=true;					
				}
				$scope.disableSubmitButton=true;
			} else {
				$scope.requestInstructionsError=false;
			}
			
			console.log('$scope.disableSubmitButton :'+$scope.disableSubmitButton);
			return $scope.disableSubmitButton;
		}

		/**
		 * function to validate the product options
		 */
		function validateProductOptions(){
			var products = newRequestFactory.productSpecificQuestions || [];

			for (var i = products.length - 1; i >= 0; i--) {
				var questions=products[i].questions || [];
				for (var j = questions.length - 1; j >= 0; j--) {
					if((questions[j].answer == undefined || questions[j].answer.length==0) && questions[j].isMandatory)
						return false;
				};
			};
			return true;
		}


		/**
		 * function to validate the alphanumeric character in the request name
		 * @param request name
		 */
		function testAlphaNumeric(requestName){
			var regex = new RegExp("^[a-zA-Z0-9\\s]+$");
			console.log('testAlphaNumeric response :'+regex.test(requestName));
		    if(regex.test(requestName)){
		    	return true;
		    }
		    return false;
		}

		/**
		 * function to cancel the revise request 
		 */
		function cancelRevise(){
			WL.SimpleDialog.show("Cancel Revise", "Do you want to cancel this revision without finalizing your changes ?", [{
				text: "Continue",
				handler: function(){
					handleBackButton();
				}
			},{
			  text : "Cancel"
			}]);	
		}

		/**
		 * function to handle the back button
		 */
		function handleBackButton(){			
			resetFields();
			broadCastHandleBack();			
		}
		
		/**
		 * function to broadcast the back button action
		 */
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack", {'RequestRevisionSK':newRequestFactory.selectedRequestQuote.RequestRevisionSK});
		}

		/**
		 * function to reset the revise request fields
		 */
		function resetFields(){
			newRequestFactory.setRequest(undefined);
			newRequestFactory.isSubmitButtonClicked=false;
			newRequestFactory.questionsSaveClicked=false;
			newRequestFactory.temporaryNotificationEmails=[];
			newRequestFactory.temporarySelectedContacts=[];
			newRequestFactory.productSpecificQuestions=[];
		}

	}
})();
(function(){
	'use strict';
	
selectItemtoReviseController.$inject = ['$scope', '$rootScope', 'newRequestFactory', '$state', '$timeout', '$stateParams'];
	angular.module('ccMobile.requests')
		.controller('selectItemtoReviseController', selectItemtoReviseController);
	
	/**
	 * main function that controlls the select item to revise page
	 */
	function selectItemtoReviseController($scope, $rootScope, newRequestFactory, $state, $timeout, $stateParams){
		console.log("came inside selectItemtoReviseController",$stateParams.RequestRevisionSK);	

		$scope.goToReviseQuote = goToReviseQuote;
		$scope.handleBackButton = handleBackButton;
		$scope.changeTabContentTo = changeTabContentTo;
		$scope.onTypeSelected = onTypeSelected;		
		$scope.selectedReviseProduct = newRequestFactory.selectedReviseProduct;
		
		$scope.tabIndex = {
			index:newRequestFactory.selectedReviseTab,
			title: "Select Revise Type"
		};

		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});

		init();

		/**
		 * initialization function
		 */
		function init(){
			refreshTitle();
			loadLocalQuote();
			loadQuoteConfig();
		}


		/**
		 * function to refresh the title
		 */
		function refreshTitle(){
			console.log('refreshing screen title ', $scope.tabIndex);
			if($scope.tabIndex.index == 1){
				$scope.tabIndex.title = 'Select Revise Type';
			} else if($scope.tabIndex.index == 2){
				$scope.tabIndex.title = 'Select Config To Revise';
			} else {
				$scope.tabIndex.title = 'Select Quote To Revise';
			}	
			//$scope.$apply();
		}

		/**
		 * function to load the quote
		 */
		function loadLocalQuote(){
			console.log('selectItemtoReviseController: Goin to load quote: ', $stateParams.RequestRevisionSK);
			$scope.reviseQuotes = newRequestFactory.selectedRequestQuote.quotes;

			/*
			quoteDetailCacheService.getQuoteDetail($stateParams.RequestRevisionSK)
			.then(function(result){
				
				if(result.length > 0){
					newRequestFactory.selectedRequestQuote = result[0].json;
					$scope.reviseQuotes = result[0].json.quotes;
					
					$scope.reviseQuotes = [];
					if(quotes){
						quotes = quotes.filter(function(e){ return angular.isObject(e) && e.customerViewActivated == 'Y' });
						quotes.forEach(function(quote){
							if(quote.Products && quote.Products.length > 0){
								quote.selectedProduct = quote.Products[0];
								$scope.reviseQuotes.push(angular.copy(quote));
								
								quote.Products.forEach(function(product){
									quote.selectedProduct = product;
									$scope.reviseQuotes.push(angular.copy(quote));
								}); 
								
							}
						});
					}
									
				}else{
					//$rootScope.logout();
				}
			}, function(message){
				console.log('selectItemtoReviseController: Error retrieving quote from local');
			});
			*/
		}

		/**
		 * function to load the quotes config
		 */
		function loadQuoteConfig(){
			newRequestFactory.getNewRequest("modify")
			.then(function(request){

				var allProducts = request.LookupLists || [];

				var filteredProducts = allProducts.filter(function(product){
					return (product.EntityTemplateSk == newRequestFactory.selectedReviseProduct.EntityTemplateSk)
							&& (product.IsSpecialDesign == true);
				});

				$scope.isReviseConfigurable = filteredProducts.length > 0;

				if($scope.isReviseConfigurable){
					var fileTypes = newRequestFactory.selectedRequestQuote.requestTemplateParser
                    	.filter(function(element){ return element.RequestTemplateSk === newRequestFactory.selectedReviseProduct.EntityTemplateSk && element.IsRevisable; })
                    	.map(function (element) { return element.FileExtensionCode.replace('.', '').toUpperCase(); });


                    console.log(newRequestFactory.selectedRequestQuote, newRequestFactory.selectedRequestQuote)
			        $scope.configFiles = newRequestFactory.selectedRequestQuote.entityFiles.filter(function (element) { 
			        	return (element.ActionSk != null) && (element.SourceReferenceID == newRequestFactory.selectedReviseProduct.OldRequestNumber) && (fileTypes.indexOf(element.AttachmentExtension.replace('.', '').toUpperCase()) >= 0 ); 
			        });

		            console.log('selectItemtoReviseController: config loaded',fileTypes,$scope.configFiles,newRequestFactory.selectedRequestQuote,newRequestFactory.selectedReviseProduct);
				}
			},function(){
				//Error Callback
				console.log("reviseQuoteController: error retrieving newRequest");
				WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
				  text : "OK",
				  handler: function(){
				  	handleBackButton();
				  }
				}]);
			});
			
		}

		/**
		 * function to navigate to teh reviseQuote page
		 * @param isConfig
		 * @param quoteOrconfig
		 */
		function goToReviseQuote(isConfig, quoteOrConfig){
			console.log("Going to reviseQuote", quoteOrConfig, isConfig);
			newRequestFactory.isReviseConfig = isConfig;

			if(isConfig){				
				newRequestFactory.selectedReviseQuote = undefined;
				newRequestFactory.selectedReviseConfig = quoteOrConfig;
				//newRequestFactory.request.reviseQuoteName = 'Revise Config';	
			} else {
				newRequestFactory.selectedReviseQuote = quoteOrConfig;	
				newRequestFactory.selectedReviseConfig = undefined;
				//newRequestFactory.request.reviseQuoteName = 'Revise Quote';
			}
			
			$state.go('reviseQuote', {'RequestRevisionSK':$stateParams.RequestRevisionSK});
		}

		/**
		 * function triggered when the revise type is selected
		 */
		function onTypeSelected(isConfig){
			if(isConfig){
				if($scope.configFiles && $scope.configFiles.length > 1){
					newRequestFactory.selectedReviseTab = 2;
					changeTabContentTo(2);					
				} else if($scope.configFiles && $scope.configFiles.length == 1){
					newRequestFactory.selectedReviseTab = 1;
					goToReviseQuote(true, $scope.configFiles[0]);
				} else {
					//no configs present go to revise detail
					newRequestFactory.selectedReviseTab = 1;
					goToReviseQuote(true);
				}
			} else {
				if($scope.reviseQuotes && $scope.reviseQuotes.length > 1){
					newRequestFactory.selectedReviseTab = 3;
					changeTabContentTo(3);
				} else if($scope.reviseQuotes && $scope.reviseQuotes.length == 1){
					newRequestFactory.selectedReviseTab = 1;
					goToReviseQuote(false, $scope.reviseQuotes[0]);
				} else {
					newRequestFactory.selectedReviseTab = 1;
					goToReviseQuote(false);
				}
			}
		}

		/**
		 * function to change the tab
		 */
		function changeTabContentTo(index){
			$timeout(function(){
				
			},0);
			$scope.tabIndex.index = index;
			refreshTitle();			
		}

		/**
		 * function to handle the back button
		 */
		function handleBackButton(){
			if($scope.tabIndex.index == 1){
				resetFields();
				broadCastHandleBack();
			} else {
				changeTabContentTo(1);
			}
		}
		
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack", {'RequestRevisionSK':$stateParams.RequestRevisionSK});
			//history.back();
		}

		/**
		 * function to reset the fields
		 */
		function resetFields(){
			newRequestFactory.isReviseConfig = false;
			newRequestFactory.selectedReviseQuote = undefined;
			newRequestFactory.selectedReviseConfig = undefined;
			newRequestFactory.selectedReviseTab = 1;

		}

}

})();
(function(){
	'use strict';
	
selectProductToReviseController.$inject = ['$scope', '$rootScope', 'newRequestFactory', '$state', '$stateParams'];
	angular.module('ccMobile.requests')
		.controller('selectProductToReviseController', selectProductToReviseController);


	/**
	 * main function that controls the select products to revise page
	 */
	function selectProductToReviseController($scope, $rootScope, newRequestFactory, $state, $stateParams){
		console.log("came inside selectProductToReviseController",$stateParams.RequestRevisionSK);	
		
		$scope.handleBackButton = handleBackButton;
		$scope.goToReviseQuoteItems = goToReviseQuoteItems;
		$scope.getCustomProductName = getCustomProductName;
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
		

		/**
		 * function that loads the products from the selected quote
		 */
		function loadLocalQuote(){
			console.log('selectProductToReviseController: Goin to load quote');
			$scope.products = newRequestFactory.selectedRequestQuote.products;
		}

		/**
		 * function to navigate to the selectItem to revise page
		 */
		function goToReviseQuoteItems(product){
			newRequestFactory.selectedReviseProduct = product;
			console.log("going to reviseQuoteItems",$stateParams.RequestRevisionSK);
			$state.go('selectItemtoRevise',{'RequestRevisionSK':$stateParams.RequestRevisionSK});
		}

		/**
		 * function to return the custom product name
		 * @param product object
		 */
		function getCustomProductName(product){
			console.log('in getCustomProductName method');
			console.log(product);
			if(product.ProductName != product.SupplierName + " - " + product.EntityTemplateName)
				return product.ProductName;

			var productName = product.EntityTemplateName;
			
			if(product.productIndexCount > 0){
				if(product.productIndexCount != 1) {
					productName = productName + ' ' + product.productIndexCount;
				}
			} 

			return productName;			
		}


		/**
		 * function to handle the back button
		 */
		function handleBackButton(){
			resetFields();
			broadCastHandleBack();
		}
		
		/**
		 * function to broadcast the back button action
		 */
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack", {'RequestRevisionSK':$stateParams.RequestRevisionSK});
			//history.back();
		}

		/**
		 * function to reset the fields in the page
		 */
		function resetFields(){			
			newRequestFactory.selectedReviseProduct = undefined;
		}
		
		loadLocalQuote();

}

})();
(function(){
	'use strict';
	
	copyNotesAndFilesController.$inject = ['$scope', '$rootScope', 'newRequestFactory', '$state', '$timeout', '$stateParams'];
	angular.module('ccMobile.requests')
		.controller('copyNotesAndFilesController', copyNotesAndFilesController);
	
	/**
	 * function that controls the copy notes and files functionality
	 */
	function copyNotesAndFilesController($scope, $rootScope, newRequestFactory, $state, $timeout, $stateParams){		
		
		$scope.handleBackButton = handleBackButton;
		$scope.request = newRequestFactory.getRequest();
		$scope.toggleCopyAll = toggleCopyAll;
		$scope.toggleCopyAllFiles = toggleCopyAllFiles;
		$scope.toggleCopyAllNotes = toggleCopyAllNotes;
		$scope.isCopyAll = isCopyAll;
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});


		/**
		 * function to check to copy all files and notes
		 */
		function isCopyAll(){
			return (!$scope.request.isRemoveAllFiles && !$scope.request.isRemoveAllNotes);
		}

		function toggleCopyAll(){
			if(isCopyAll()){
				$scope.request.isRemoveAllFiles = true;
				$scope.request.isRemoveAllNotes = true;
			} else {
				$scope.request.isRemoveAllFiles = false;
				$scope.request.isRemoveAllNotes = false;
			}
		}



		/**
		 * function to toggle the copy/remove all files
		 */
		function toggleCopyAllFiles(){
			if($scope.request.isRemoveAllFiles){
				$scope.request.isRemoveAllFiles = false;
			} else {
				$scope.request.isRemoveAllFiles = true;
			}
		}

		/**
		 *  function to toggle the copy/remove all notes
		 */
		function toggleCopyAllNotes(){
			if($scope.request.isRemoveAllNotes){
				$scope.request.isRemoveAllNotes = false;
			} else {
				$scope.request.isRemoveAllNotes = true;
			}
		}

		/**
		 * function to handle back button action
		 */
		function handleBackButton(){
			newRequestFactory.setRequest($scope.request);
			broadCastHandleBack();
		}
		
		/**
		 * function to broadcast the back button action
		 */
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
			//history.back();
		}	
	}
})();
(function(){
	'use strict';
	
	productSpecificQuestionsController.$inject = ['$scope', '$rootScope', 'newRequestFactory', '$timeout', 'loadingOverlayService'];
	userEmailsController.$inject = ['$scope', '$stateParams', '$rootScope', 'newRequestFactory'];
	angular.module('ccMobile.requests')
		.controller('deviceContactsController', productSpecificQuestionsController)
		.controller('userEmailsController', userEmailsController);


	/**
	 * function that controls the product specific questions functionality
	 */
	function productSpecificQuestionsController($scope, $rootScope, newRequestFactory,$timeout, loadingOverlayService){
		$scope.handleBackButton = handleBackButton;
		$scope.orderContacts=orderContacts;
		$scope.blurElement=blurElement;
		$scope.showAlphabetScrolling=true;
		loadingOverlayService.show();
		navigator.contacts.find(["name"],function(res){
			$scope.$apply(function(){
				$scope.contacts = res.map(function(cnt){
					var contact = {
							id : cnt.id,
							displayName : cnt.displayName
					};
					if(cnt.displayName == null){
						if(!cnt.name.formatted || cnt.name.formatted == ""){
							if(cnt.emails && cnt.emails.length > 0){
								contact.displayName = cnt.emails[0].value;
							}else{
								contact.displayName = "Not Specified";
							}
						}else{
							contact.displayName = cnt.name.formatted;
						}
					}
					return contact;
				});
				loadingOverlayService.hide();
			});
		},function(){
			$scope.$apply(function(){
				$scope.contacts = [];
				loadingOverlayService.hide();
			});
		},{
			filter: "",
			multiple: true,
		});

		/**
		 * function to order the contacts in a specific format
		 * 
		 */
		function orderContacts(contact){
			var charCode = (contact.displayName).toUpperCase().charCodeAt(0);
			if(charCode >= 65 && charCode<=122){
				return contact.displayName;
			}
			else if(charCode >= 48 && charCode<=57){
				return "zzzzz"+(charCode + 48);
			}
			else{
				return "zzzzzzzz"+(charCode + 122);
			}
		}

		/**
		 * function to blur any element in the html
		 * @param elementId
		 */
		function blurElement(elementId){
			$timeout(function(){
				document.getElementById(elementId).blur();
			});
		}
		
		/**
		 * function to handle the back button action
		 */
		function handleBackButton(){
			broadCastHandleBack();
		}
		
		/**
		 * function to broadcast the back button action
		 */
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
		}
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
	}
	
	
	/**
	 * controller for selecting the emails from the selected contacts
	 */
	function userEmailsController($scope, $stateParams, $rootScope, newRequestFactory){
		$scope.handleBackButton = handleBackButton;
		$scope.selectedContacts = newRequestFactory.temporarySelectedContacts || [];
		$scope.addedContacts = newRequestFactory.temporaryNotificationEmails;
		
		$scope.isEmailAdded = isEmailAdded;
		$scope.addOrRemoveEmail = addOrRemoveEmail;
		
		function isEmailAdded(emailId){
			emailId=emailId.toLowerCase();
			return $scope.selectedContacts.indexOf(emailId) != -1;
		}
		
		function addOrRemoveEmail(emailId){
			emailId=emailId.toLowerCase();
			if(isEmailAdded(emailId)){
				var index = $scope.selectedContacts.indexOf(emailId);
				$scope.selectedContacts.splice(index, 1);
			}else{
				$scope.selectedContacts.push(emailId);
				if($scope.addedContacts.indexOf(emailId) == -1)
					$scope.addedContacts.push(emailId);
			}
		}
		
		navigator.contacts.find(["id"],function(res){
			if(res.length > 0){
				$scope.$apply(function(){
					$scope.emails = res[0].emails.map(function(e){ return e.value;});
				});
			}
		},function(){
		},{
			filter: $stateParams.id,
			multiple: true,
		});
		
		function handleBackButton(){
			newRequestFactory.temporaryNotificationEmails=$scope.addedContacts;
			newRequestFactory.temporarySelectedContacts=$scope.selectedContacts;
			broadCastHandleBack();
		}
		
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
		}
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
	}

})();
(function(){
	'use strict';
	
	disclaimerController.$inject = ['$scope', '$state', '$rootScope', 'newRequestFactory', '$sce'];
	angular.module('ccMobile.requests')
		.controller('disclaimerController', disclaimerController);
	
	/**
	 * controller for the disclaimer page when the request is submitted
	 */
	function disclaimerController($scope,$state,$rootScope,newRequestFactory,$sce){
		var disclaimers = newRequestFactory.disclaimers.map(function(a){
			return a.Disclaimer;
		}).join("");
		$scope.disclaimer={};
		$scope.disclaimer.content=disclaimers;
		$scope.disclaimer.content = $sce.trustAsHtml($scope.disclaimer.content);
		$scope.disclaimer.isSelected=false;
		$scope.submitRequestDisclaimerPage=submitRequestDisclaimerPage;
		$scope.handleBackButton=handleBackButton;

		function submitRequestDisclaimerPage(){
			if(!$scope.disclaimer.isSelected){
				$scope.disclaimerError=true;
			}
			else{
				if(newRequestFactory.isEndUserNotRequired){
					var request = newRequestFactory.getRequest();
					request.addedEndUsers.length = 0;
					newRequestFactory.setRequest(request);
				}
				newRequestFactory.submitRequest()
				.then(function(){
					/*newRequestFactory.setRequest(undefined);
					newRequestFactory.isSubmitButtonClicked=false;
					newRequestFactory.questionsSaveClicked=false;
					newRequestFactory.temporaryNotificationEmails=[];
					newRequestFactory.temporarySelectedContacts=[];	
					newRequestFactory.productSpecificQuestions=[];*/
					newRequestFactory.resetNewRequest();
					$state.go('^.submissionSuccessful');
				}, function(){
					WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
					  text : "OK",
					  handler: function(){
					  	$state.go('^.newRequest');
					  }
					}]);
				});
			}
		}

		function handleBackButton(){
			broadCastHandleBack();
		}
		
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
		}
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
	}
})();
(function(){
	'use strict';
	
	multiOptionsController.$inject = ['$scope', '$rootScope', '$stateParams', 'newRequestFactory'];
	angular.module('ccMobile.requests')
		.controller('multiOptionsController', multiOptionsController);


	/**
	 * controller for product questions multiple answer options functionality
	 */
	function multiOptionsController($scope, $rootScope, $stateParams, newRequestFactory){
		//variables
		$scope.question = newRequestFactory.productSpecificQuestions[$stateParams.productIndex].questions[$stateParams.questionIndex];
		
		//methods
		$scope.handleBackButton = handleBackButton;
		$scope.addOrRemoveOption = addOrRemoveOption;
		$scope.isOptionAdded = isOptionAdded;
		
		function handleBackButton(){			
			broadCastHandleBack();
		}
		
		/**
		 * function to check if an option is added 
		 */
		function isOptionAdded(option){
			var matchedOptions = $scope.question.answer.filter(function(addedOption){
				return addedOption.option == option.option;
			});
			return matchedOptions.length != 0;
		}
		
		/**
		 * function to add or remove an option
		 * @param option
		 */
		function addOrRemoveOption(option){
			if(isOptionAdded(option)){
				var index = $scope.question.answer.map(function(opt){ return opt.option;}).indexOf(option.option);
				$scope.question.answer.splice(index,1);
			}else{
				if($scope.question.max == 1){
					$scope.question.answer = [option];
				}else{
					if($scope.question.answer.length < $scope.question.max){
						$scope.question.answer.push(option);
					}
				}
			}
		}
		
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
		}
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
	}

})();
var productSpecificQuestionsScope;
(function(){
	'use strict';
	
	productSpecificQuestionsController.$inject = ['$scope', '$rootScope', 'newRequestFactory'];
	angular.module('ccMobile.requests')
		.controller('productSpecificQuestionsController', productSpecificQuestionsController);
	
	/**
	 * controller for product specific questions
	 */
	function productSpecificQuestionsController($scope, $rootScope, newRequestFactory){
		productSpecificQuestionsScope=$scope;
		$scope.product = newRequestFactory.productSpecificQuestions[newRequestFactory.showQuestionsOfProductIndex];
		$scope.productIndex = newRequestFactory.showQuestionsOfProductIndex;
		$scope.addOption=addOption;
		$scope.isOptionAdded=isOptionAdded;
		$scope.getCustomProductName = getCustomProductName;
		$scope.handleBackButton = handleBackButton;

		$scope.title = 'Options for ' + getCustomProductName($scope.product);


		$scope.question=$scope.product.questions.filter(function(e){return e.title=='Is this a current contract'});
		if($scope.question.length>0){
			$scope.question=$scope.question[0];
		}
		/**
		 * function to check if an option is added
		 */
		function isOptionAdded(option,question){
			var matchedOptions = question.answer.filter(function(addedOption){
				if(!angular.isObject(option)){
					return addedOption.option == option;
				}
				else{
					return addedOption.option == option.option;
				}
			});
			return matchedOptions.length != 0;
		}
		
		/**
		 * function to add an option
		 * @param option
		 * @param question
		 */
		function addOption(option,question){
			if(!angular.isObject(option)){
				option=question.options.filter(function(e){ return e.option==option})[0];
			}
			question.answer = [option];
		}

		/**
		 * function to return the custom product name
		 * @param product
		 */
		function getCustomProductName(product){
			var productName = product.EntityTemplateName;

			if(product.productIndexCount > 0){
				if(product.productIndexCount != 1) {
					productName = productName + ' ' + product.productIndexCount;
				}
			} 

			return productName;			
		}

		function handleBackButton(){
			broadCastHandleBack();
		}
		
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
		}
		
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
	}

})();
(function(){
	'use strict';
	
	productsWithQuestionsController.$inject = ['$scope', '$rootScope', 'newRequestFactory', '$state'];
	angular.module('ccMobile.requests')
		.controller('productsWithQuestionsController', productsWithQuestionsController);


	/**
	 * controller to handle the products with questions
	 */
	function productsWithQuestionsController($scope, $rootScope, newRequestFactory,$state){
		$scope.products = newRequestFactory.productSpecificQuestions;
		$scope.redirectToQuestions=redirectToQuestions;
		$scope.areRequiredQuestionsAnswered=areRequiredQuestionsAnswered;
		$scope.getCustomProductName = getCustomProductName;
		$scope.handleBackButton=handleBackButton;


		/**
		 * function to check if all questions are answered
		 * @param index
		 */
		function areRequiredQuestionsAnswered(index){
			var questions=newRequestFactory.productSpecificQuestions[index].questions || [];
			for (var i = questions.length - 1; i >= 0; i--) {
				if((questions[i].answer== null || questions[i].answer==undefined || questions[i].answer.length==0) && questions[i].isMandatory)
					return false;
			}
			return true;
		}

		/**
		 * function to redirect to questions
		 * @param index
		 */
		function redirectToQuestions(index){
			newRequestFactory.showQuestionsOfProductIndex=index;
			$state.go('productQuestions');
		}

		/**
		 * function to return the custom product name
		 * @param product
		 */
		function getCustomProductName(product){
			var productName = product.EntityTemplateName;

			if(product.productIndexCount > 0){
				if(product.productIndexCount != 1) {
					productName = productName + ' ' + product.productIndexCount;
				}
			} 

			return productName;			
		}
		
		function handleBackButton(){
			//newRequestFactory.showQuestionsOfProductIndex=undefined;
			broadCastHandleBack();
		}
		
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
		}
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
	}

})();
/**
 * 
 */
(function(){
	requestNotificationController.$inject = ['$state', '$scope', '$rootScope', 'newRequestFactory', 'recentNotificationEmails', '$timeout'];
	angular.module('ccMobile.requests')
	.controller('requestNotificationController', requestNotificationController);
	
	/**
	 * controller for the request notification screen
	 */
	function requestNotificationController($state, $scope, $rootScope, newRequestFactory, recentNotificationEmails,$timeout){
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
		$scope.enteredEmail={};
		$scope.enteredEmail.email = newRequestFactory.temporaryEmail;
		$scope.addedContacts = newRequestFactory.temporaryNotificationEmails || [];// newRequestFactory.temporaryNotificationEmails contains emails added via typeHeader and device contacts
		$scope.receivedContacts = (newRequestFactory.getRequest().Contacts || []).filter(function(e){return e.IsNotifyAssigned==true;});
		//$scope.selectedContacts = newRequestFactory.getRequest().notificationEmails || [];
		$scope.selectedContacts = newRequestFactory.temporarySelectedContacts || [];
		$scope.showOptions=false;
		$scope.showSelectionButtons=true;
		$scope.validateEmail = validateEmail;
		$scope.addEmail = addEmail;
		$scope.addNotificationContacts = addNotificationContacts;
		$scope.handleBackButton = handleBackButton;
		$scope.showDeviceContacts = showDeviceContacts;
		$scope.emailInputFocus=emailInputFocus;
		$scope.emailInputBlur=emailInputBlur;
		$scope.showAddedContactDeleteButton=showAddedContactDeleteButton;
		$scope.hideAddedContactDeleteButton=hideAddedContactDeleteButton;
		$scope.deleteAddedContact=deleteAddedContact;
		$scope.showReceivedContactDeleteButton=showReceivedContactDeleteButton;
		$scope.hideReceivedContactDeleteButton=hideReceivedContactDeleteButton;
		$scope.deleteReceivedContact=deleteReceivedContact;
		$scope.toggleContactSelection=toggleContactSelection;
		$scope.isContactSelected=isContactSelected;
		$scope.areAllContactsSelected=areAllContactsSelected;
		$scope.toggleAllSelection=toggleAllSelection;
		$scope.getUnselectedContactsOnly=getUnselectedContactsOnly;
		$scope.blurInput=blurInput;
		
		/**
		 * function to fetch the recent emails
		 */
		function getRecentEmails(){
			recentNotificationEmails.getRecentEmails()
			.then(function(res){
				$scope.recentNotificationMails = res;
			}, function(){
				$scope.recentNotificationMails = [];
			});
		}
		getRecentEmails();
		
		/**
		 * function to display the device contacts
		 */
		function showDeviceContacts(){
			newRequestFactory.temporarySelectedContacts = $scope.selectedContacts;
			$state.go("deviceContacts");
		}
		
		/**
		 * function to add a notification
		 */
		function addNotificationContacts(){
			var request = newRequestFactory.getRequest();
			request.notificationEmails = $scope.selectedContacts;
			newRequestFactory.setRequest(request);
			//handleBackButton();
		}
			
		/**
		 * function to validate the email address
		 * @param contactEmail
		 */
		function validateEmail(contactEmail) {
			contactEmail=contactEmail.toLowerCase();
		    var regex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,5}$/;
		    return ( regex.test(contactEmail) && !isEmailPresentInTheList($scope.addedContacts , contactEmail) && !isEmailPresentInTheList($scope.receivedContacts , contactEmail)) ? true : false;
		}

		/**
		 * function to check if the email is present in the list
		 * @param email list 
		 * @param email
		 */
		function isEmailPresentInTheList(list,email){
			if(
				list.map(function(e){
					if(angular.isObject(e)){
						return e.EmailAddress
					}
					else{
						return e;
					}
				}).indexOf(email) == -1
			){
				return false;
			}
			return true;
		}

		/**
		 * function to check if a contact has been selected
		 * @param contact
		 */
		function isContactSelected(contact){
			if(angular.isObject(contact)){
				return ['receivedContact',$scope.selectedContacts.filter(function(e){ return angular.isObject(e) }).map(function(e){ return e.ContactId}).indexOf(contact.ContactId)]
			}
			else{
				return ['addedContact',$scope.selectedContacts.filter(function(e){ return !angular.isObject(e) }).map(function(e){ return e}).indexOf(contact)]
					
			}
		}
			
		/**
		 * function to add the contact email
		 * @param contactEmail
		 */
		function addEmail(contactEmail){
			contactEmail=contactEmail.toLowerCase();
			if($scope.addedContacts.indexOf(contactEmail)==-1){
				recentNotificationEmails.addEmail(contactEmail)
				.then(function(){
					getRecentEmails();
				}, function(){
					getRecentEmails();
				});
				$scope.addedContacts.push(contactEmail);
				$scope.selectedContacts.push(contactEmail);
				$timeout(function(){
					document.getElementById('notificationEmail').blur();
					$scope.enteredEmail.email='';
				});
			}
		}

		/**
		 * function to toggle the contact selection
		 * @param contact
		 */
		function toggleContactSelection(contact){
			var isContactSelectedReturnValue = isContactSelected(contact);
			var selectedReceivedContactsLength=$scope.selectedContacts.filter(function(e){ return angular.isObject(e) }).length;
			if( isContactSelectedReturnValue[1] == -1){
				//contact not selected
				if(isContactSelectedReturnValue[0]=='addedContact'){
					$scope.selectedContacts.push(contact);
				}
				else if(isContactSelectedReturnValue[0]=='receivedContact'){
					$scope.selectedContacts.splice(selectedReceivedContactsLength,0,contact);
				}
			}
			else{
				if(isContactSelectedReturnValue[0]=='addedContact'){
					$scope.selectedContacts.splice(selectedReceivedContactsLength+isContactSelectedReturnValue[1],1);
				}
				else if(isContactSelectedReturnValue[0]=='receivedContact'){
					$scope.selectedContacts.splice(isContactSelectedReturnValue[1],1);
				}
			}
		}

		/**
		 * function to bring email input to focus
		 */
		function emailInputFocus(){
			$scope.showOptions=true;
			$scope.showSelectionButtons=false;
		}

		/**
		 * function to blur the email input
		 */
		function emailInputBlur(){
			$scope.showOptions=false;
			$scope.showSelectionButtons=true;
		}

		/**
		 * function to show  the delete button for the added contact
		 * @param index
		 * @param Event
		 */
		function showAddedContactDeleteButton(index,event){
			event.stopImmediatePropagation();
			event.stopPropagation();
			$scope.revealedAddedContactIndex = index;
			$scope.revealedReceivedContactIndex= "-1";

		}

		/**
		 * function to hide the delete button for the contact
		 * @param index
		 * @param Event
		 */
		function hideAddedContactDeleteButton(index,event){
			event.stopImmediatePropagation();
			event.stopPropagation();
			if(index == $scope.revealedAddedContactIndex){
				$scope.revealedAddedContactIndex= "-1";
			}	
		}

		function deleteAddedContact(contact,index){
			/*$scope.addedContacts.splice(index,1);
			var selectedIndex=$scope.selectedContacts.indexOf(contact);
			if(selectedIndex != -1)
				$scope.selectedContacts.splice(selectedIndex,1);
			$scope.revealedContactIndex= "-1";*/
		}

		/**
		 * function to show the recieved contact delete button
		 * @param index
		 * @param Event
		 */
		function showReceivedContactDeleteButton(index,event){
			event.stopImmediatePropagation();
			event.stopPropagation();
			$scope.revealedReceivedContactIndex = index;
			$scope.revealedAddedContactIndex= "-1";
		}

		/**
		 * function to hide the recieved contact button
		 * @param index
		 * @param Event
		 */
		function hideReceivedContactDeleteButton(index,event){
			event.stopImmediatePropagation();
			event.stopPropagation();
			if(index == $scope.revealedReceivedContactIndex){
				$scope.revealedReceivedContactIndex= "-1";
			}	
		}

		/**
		 * function to hide the recieved contact
		 * @param index
		 */
		function deleteReceivedContact(index){
			/*$scope.addedContacts.splice(index,1);
			$scope.revealedContactIndex= "-1";*/
			/*var selectedIndex=$scope.selectedContacts.filter()indexOf(contact);
			if(selectedIndex != -1)
				$scope.selectedContacts.splice(selectedIndex,1);
			$scope.revealedContactIndex= "-1";*/
		}


		/**
		 * function to check if all contacts are selected
		 */
		function areAllContactsSelected(){
			return ($scope.addedContacts.length + $scope.receivedContacts.length) == $scope.selectedContacts.length
		}

		/**
		 * function to toggle all contact selection
		 */
		function toggleAllSelection(){
			if(areAllContactsSelected()){
				//deselectall
				$scope.selectedContacts.length=0;
			}
			else{
				$scope.selectedContacts=$scope.receivedContacts.concat($scope.addedContacts);
			}
		}

		/**
		 * function to get the unselected contacts
		 * @param element
		 */
		function getUnselectedContactsOnly(element){
			return $scope.addedContacts.indexOf(element.email)==-1 ;
		}

		/**
		 * function to blur the input field
		 */
		function blurInput(id){
			$timeout(function(){
				document.getElementById('notificationEmail').blur();
			});
		}
		
		function handleBackButton(){
			//addNotificationContacts();
			newRequestFactory.temporaryNotificationEmails = $scope.addedContacts || [];
			newRequestFactory.temporaryEmail = "";
			newRequestFactory.temporarySelectedContacts=angular.copy($scope.selectedContacts);
			var request = newRequestFactory.getRequest();
			request.notificationEmails = $scope.selectedContacts;
			newRequestFactory.setRequest(request);
			broadCastHandleBack();
		}
		
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
		}
	}
})();
/**
 * 
 */
(function(){
	selectEndUserController.$inject = ['$scope', '$rootScope', 'newRequestFactory', 'favoriteEndUsers', '$timeout', '$filter', 'quoteDetailFactory'];
	angular.module('ccMobile.requests')
	.controller('selectEndUserController', selectEndUserController);
	
	/**
	 * controller for the select end user functionality
	 */
	function selectEndUserController($scope, $rootScope, newRequestFactory, favoriteEndUsers,$timeout,$filter,quoteDetailFactory){
		$scope.tabIndex = {index:1};
		$scope.endUserInfo={};
		$scope.endUserInfo.isEndUserNotRequired = angular.copy(newRequestFactory.isEndUserNotRequired);
		$scope.businessSector = newRequestFactory.getRequest().businessSector || "";
		$scope.addedEndUsers = newRequestFactory.getRequest().addedEndUsers || [];
		$scope.recentEndUsers = newRequestFactory.getRequest().RecentEndUsers;
		$scope.Partners=newRequestFactory.getRequest().Partners;
		$scope.favoriteEndUsers = [];
		$scope.anyEndUsersSearched=false;
		$scope.handleBackButton = handleBackButton;
		$scope.changeTabContentTo=changeTabContentTo;
		$scope.isEndUserAdded = isEndUserAdded;
		$scope.isEndUserFavorite = isEndUserFavorite;
		$scope.addOrRemoveEndUser = addOrRemoveEndUser;
		$scope.addOrRemoveFavoriteEndUser = addOrRemoveFavoriteEndUser;
		$scope.addEndUsersToRequest = addEndUsersToRequest;
		$scope.getMatchedEndUsers = getMatchedEndUsers;
		$scope.changeBusinessSector = changeBusinessSector;
		$scope.orderUsers = orderUsers;
		$scope.searchOnChangeMethod=searchOnChangeMethod;
		$scope.closeHelpScreen=closeHelpScreen;
		var temporarySearchTerm="";
		var isSearchGoClicked=false;
		var timerVariable;

		$scope.quoteDetailEndUserClicked=quoteDetailFactory.quoteDetailEndUserClicked;
		if(localStorage.getItem(localStorage.getItem('LoginId')+'hideSelectEndUserHelpScreen') != "true" && ($scope.recentEndUsers !=undefined && $scope.recentEndUsers.length>2)){
			$scope.helpOverlayShown=true;
			localStorage.setItem(localStorage.getItem('LoginId')+'hideSelectEndUserHelpScreen',"true");
			var temporaryRecentEndUsers=$scope.recentEndUsers;
			temporaryRecentEndUsers=$filter('orderBy')(temporaryRecentEndUsers,$scope.orderUsers);
			$scope.addedEndUsers.pop();
			$scope.addedEndUsers.push(temporaryRecentEndUsers[2]);
			//$scope.addOrRemoveEndUser(temporaryRecentEndUsers[2]);
			angular.element(document).ready(function (){
				$rootScope.$broadcast("toggle-selectEndUserHelpModal");
		    });
		}
		
		if(!hasUS33SalesOrgPartner($scope.Partners)){
			$scope.businessSector='Commercial';
			$scope.commercialAutoSelected=true;
			$scope.IsGovernmentRequest=false;
		}

		/**
		 * function to order the users 
		 * @param name
		 */
		function orderUsers(name){
			var charCode = name.PartnerName.toUpperCase().charCodeAt(0);
			if(charCode >= 65 && charCode<=122){
				return name.PartnerName;
			}else{
				return "zzzzz"+(charCode + 122);
			}
		};
		
		/**
		 * function to get the favorite end users
		 */
		function getFavoriteEndUsers(){
			favoriteEndUsers.getFavoriteEndUsers()
			.then(function(favoriteEndUsers){
				$scope.favoriteEndUsers = favoriteEndUsers;
			},function(){
				
			});
		}
		getFavoriteEndUsers();

		function changeTabContentTo(index){
			$timeout(function(){
				$scope.tabIndex.index = index;
			},0);
		}
		
		/**
		 * function to check if the end user has been added
		 * @param endUser
		 */
		function isEndUserAdded(endUser){
			var user = $scope.addedEndUsers.filter(function(a){
				return endUser.PartnerId == a.PartnerId;
			});
			return user.length!=0;
		}
		
		/**
		 * 
		 */
		function isEndUserFavorite(endUser){
			var user = $scope.favoriteEndUsers.filter(function(a){
				return parseInt(endUser.PartnerId) == a.PartnerId;
			});
			return user.length!=0;
		}
		
		/**
		 * function to add or remove the end user
		 * @param enduser
		 */
		function addOrRemoveEndUser(endUser){
			if(isEndUserAdded(endUser)){
				var index = $scope.addedEndUsers.map(function(e){return e.PartnerId;}).indexOf(endUser.PartnerId);
				$scope.addedEndUsers.splice(index,1);
			}else{
				$scope.addedEndUsers.pop();
				$scope.addedEndUsers.push(endUser);
			}
		}
		
		/**
		 * function to add or remove favorite end user
		 */
		function addOrRemoveFavoriteEndUser(endUser,event){
			if(!isEndUserAdded(endUser)){
				event.preventDefault();
				event.stopPropagation();
				if(isEndUserFavorite(endUser)){
					favoriteEndUsers.removeEndUser(endUser)
					.then(function(){
						getFavoriteEndUsers();
					});
				}else{
					favoriteEndUsers.addEndUser(endUser)
					.then(function(){
						getFavoriteEndUsers();
					});
				}
			}else{
				//event propagates here and executes addOrRemoveEndUser 
			}
		}
		
		/**
		 * funtion to change the business options
		 * @param sector
		 */
		function changeBusinessSector(sector){
			if(!$scope.commercialAutoSelected){
				$scope.businessSector = sector;
				if(sector=='Commercial')
					$scope.IsGovernmentRequest=false;
				else if(sector=='Fed/Sled')
					$scope.IsGovernmentRequest=true;
			}

		}
		
		/**
		 * function to add end users to the request
		 */
		function addEndUsersToRequest(){
			var request = newRequestFactory.getRequest();
			request.addedEndUsers = angular.copy($scope.addedEndUsers);
			request.businessSector = angular.copy($scope.businessSector);
			newRequestFactory.setRequest(request);
			newRequestFactory.isEndUserNotRequired = angular.copy($scope.endUserInfo.isEndUserNotRequired);
		}
		
		/**
		 * function to fetch the matched end users
		 * @param searchTerm
		 * @param searchField
		 */
		function getMatchedEndUsers(searchTerm,searchFieldId){
			if(searchTerm.length>=3){
				isSearchGoClicked=true;
				updateSearchResults(searchTerm,searchFieldId);
			}
		}

		/**
		 * function to update the search results
		 * @param searchTerm
		 * @param searchField id
		 */
		function updateSearchResults(searchTerm,searchFieldId){
			temporarySearchTerm=searchTerm;
			$timeout(function() { 
				document.getElementById(searchFieldId).blur();
			});
			newRequestFactory.getMatchedEndUsers(searchTerm)
			.then(function(result){
				result.Partners = result.Partners || [];
				$scope.matchedEndUsers = result.Partners;
				$scope.anyEndUsersSearched=true;
			}, function(){
				console.log('in getMatchedEndUsers error method');
				WL.SimpleDialog.show("Service Unavailable", "Please verify connectivity and try again.", [{
					text : "OK"
				}]); 
			});
		}

		/**
		 * function triggered each time when the search term changes
		 */
		function searchOnChangeMethod(searchTerm,searchFieldId){
			$timeout.cancel(timerVariable);
			if(searchTerm.length >= 3 && searchTerm.length>temporarySearchTerm.length && isSearchGoClicked){
				timerVariable= $timeout(function(){
									updateSearchResults(searchTerm,searchFieldId);
								},750);
			}
			else{
				if(searchTerm.length <= temporarySearchTerm.length){
					isSearchGoClicked=false;
				}
			}
		}

		/**
		 * function to check if the partner code has US33 value
		 * @param partners
		 */
		function hasUS33SalesOrgPartner(partners){
			for(var i=0;i<(partners || []).length;i++){
				if(partners[i].SalesOrganizations.map(function(item){return item.SalesOrgCode;}).indexOf('US33') != -1){
					return true;
				}
			}
			return false;
		}

		/**
		 * function to close the help screen
		 */
		function closeHelpScreen(){
			$scope.helpOverlayShown=false;
			var temporaryRecentEndUsers=$scope.recentEndUsers;
			temporaryRecentEndUsers=$filter('orderBy')(temporaryRecentEndUsers,$scope.orderUsers);
			$scope.addedEndUsers.pop();
			//$scope.addOrRemoveEndUser(temporaryRecentEndUsers[2]);
			$scope.addedEndUsers = newRequestFactory.getRequest().addedEndUsers || [];
			$rootScope.$broadcast("toggle-selectEndUserHelpModal");
		}
		

		function handleBackButton(){
			if($scope.helpOverlayShown){
				$scope.closeHelpScreen();
			}
			var request = newRequestFactory.getRequest();
			request.addedEndUsers = angular.copy($scope.addedEndUsers);
			request.businessSector = angular.copy($scope.businessSector);
			request.IsGovernmentRequest=angular.copy($scope.IsGovernmentRequest);
			newRequestFactory.setRequest(request);
			newRequestFactory.isEndUserNotRequired = angular.copy($scope.endUserInfo.isEndUserNotRequired);
			broadCastHandleBack();
		}
		
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
		}
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
	}
})();
(function(){
	'use strict';
	
	selectProductController.$inject = ['$scope', '$rootScope', '$timeout', 'favoriteProducts', 'newRequestFactory'];
	angular.module('ccMobile.requests')
		.controller('selectProductController', selectProductController);


	/**
	 * controller for the product selelction page
	 */
	function selectProductController($scope, $rootScope, $timeout, favoriteProducts, newRequestFactory){
		//variables
		$scope.tabIndex = {index:1};
		$scope.addedProducts = newRequestFactory.getRequest().Products || [];
		$scope.recentProducts = newRequestFactory.getRequest().RecentProducts || [];
		$scope.allProducts = newRequestFactory.getRequest().LookupLists || [];
		$scope.favoriteProducts = [];
		$scope.tempProductsToBeRemoved = [];	
		$scope.filteredProducts = [];	
		$scope.removedProductIndexes = newRequestFactory.removedProductIndexes;
		//methods
		$scope.changeTabContentTo=changeTabContentTo;
		$scope.handleBackButton = handleBackButton;
		$scope.isProductAdded = isProductAdded;
		$scope.isProductFavorite = isProductFavorite;
		$scope.addOrRemoveProduct = addOrRemoveProduct;
		$scope.addProductAgain = addProductAgain;
		$scope.addOrRemoveProductTemporarily = addOrRemoveProductTemporarily;
		$scope.toggleAllProductSelection = toggleAllProductSelection;
		$scope.areAllProductsSelected = areAllProductsSelected;
		$scope.getCustomProductName = getCustomProductName;
		$scope.isProductToBeRemoved = isProductToBeRemoved;
		$scope.showRemoveAllProductsModal = showRemoveAllProductsModal;
		$scope.cancelRemoveAllProductsModal = cancelRemoveAllProductsModal;
		$scope.removeSelectedProducts = removeSelectedProducts;
		$scope.addOrRemoveFavoriteProduct = addOrRemoveFavoriteProduct;
		$scope.removeProduct = removeProduct;
		$scope.blurElementWithId=blurElementWithId;
		var productsHavingQuestions = [21, 22, 23, 24, 26, 45, 46, 47, 69, 374];

		//method implementation
		function changeTabContentTo(index){
			$timeout(function(){
				$scope.tabIndex.index = index;
			},0);
		}
		
		/**
		 * function that returns favorite products
		 */
		function getFavoriteProducts(){
			favoriteProducts.getFavoriteProducts(angular.copy($scope.allProducts))
			.then(function(favoriteProducts){
				$scope.favoriteProducts = favoriteProducts;
			},function(){
				
			});
		}
		getFavoriteProducts();
		
		/**
		 * function to check if the product is added
		 */
		function isProductAdded(product){
			var prod = $scope.addedProducts.filter(function(a){
				return product.EntityTemplateSk == a.EntityTemplateSk;
			});
			return prod.length;
		}
		
		/**
		 * function to check if added product is favorite product
		 */
		function isProductFavorite(product){
			var user = $scope.favoriteProducts.filter(function(a){
				return parseInt(product.EntityTemplateSk) == a.EntityTemplateSk;
			});
			return user.length!=0;
		}
		
		/**
		 * function to add or remove a product
		 */
		function addOrRemoveProduct(product){
			var productsChanged=true;
			/*
			product = $scope.allProducts.filter(function(e){ 
				return (e.EntityTemplateSk == product.EntityTemplateSk) && (e.suffix) ;
			});*/


			var sameProductCount = isProductAdded(product);
			if(sameProductCount == 0){
				//add the product
				product.productIndexCount = 1;
				addProduct(product);
				//reset the already removed indexes
				var alreadyRemovedIndexes =  $scope.removedProductIndexes[product.EntityTemplateSk.toString()];
				alreadyRemovedIndexes.length = 0;
			} else {
				//var index = $scope.addedProducts.map(function(e){return e.EntityTemplateSk;}).indexOf(product.EntityTemplateSk);
				//$scope.productToRemove = index;
				$scope.selectedProduct = product;
				$rootScope.$broadcast("toggle-removeProductModal");
			}
			
			/*
		   if(isProductAdded(product)){
				var index = $scope.addedProducts.map(function(e){return e.EntityTemplateSk;}).indexOf(product.EntityTemplateSk);
				$scope.productToRemove = index;
				$rootScope.$broadcast("toggle-removeProductModal");
			}else{
				
			}*/
		}

		
		function addProductAgain(){
			if($scope.selectedProduct){
				var newProduct = angular.copy($scope.selectedProduct);
				var sameProductCount = isProductAdded($scope.selectedProduct);
				var selectedProductSk = $scope.selectedProduct.EntityTemplateSk.toString();
				var nextProductCount;
				var alreadyRemovedIndexes = $scope.removedProductIndexes[selectedProductSk];


				console.log('selectProductController: addProductAgain: ', selectedProductSk, $scope.removedProductIndexes,$scope.selectedProduct);

				if(alreadyRemovedIndexes && alreadyRemovedIndexes.length > 0) {
					nextProductCount = Math.min.apply(null, alreadyRemovedIndexes);
					alreadyRemovedIndexes.splice(alreadyRemovedIndexes.indexOf(nextProductCount),1);
				}

				if (nextProductCount) {
					newProduct.productIndexCount = nextProductCount;
				} else {
					newProduct.productIndexCount = sameProductCount + 1;	
				}
				addProduct(newProduct);
				$rootScope.$broadcast("toggle-removeProductModal");
			}
		}

		/**
		 * function to add or remove the product
		 * @param product
		 */
		function addOrRemoveProductTemporarily(product){
			var index = $scope.tempProductsToBeRemoved.indexOf(product);
			if(index == -1){
				console.log('selectProductController: Goin to add product to remove list', product, $scope.tempProductsToBeRemoved);
				$scope.tempProductsToBeRemoved.push(product);
			} else {
				console.log('selectProductController: Going to remove product from remove list', product);
				$scope.tempProductsToBeRemoved.splice(index,1);				
			}
		}

		/**
		 * function to toggle product selection
		 */
		function toggleAllProductSelection(){
			console.log("selectProductController: filteredProducts", $scope.filteredProducts, $scope.tempProductsToBeRemoved);
			if(areAllProductsSelected()){
				//deselectall
				console.log("Deselecting all");
				$scope.tempProductsToBeRemoved.length=0;
			} else {
				console.log("Selecting all");
				$scope.tempProductsToBeRemoved.length =0;
				$scope.tempProductsToBeRemoved.push.apply($scope.tempProductsToBeRemoved, $scope.filteredProducts);
			}
		}

		/**
		 * function to check if all products are selected
		 */
		function areAllProductsSelected(){
			/*console.log("filteredProducts: ", $scope.filteredProducts);*/
			return $scope.tempProductsToBeRemoved && $scope.filteredProducts && ($scope.tempProductsToBeRemoved.length == $scope.filteredProducts.length);
		}

		/**
		 * function to get the product name 
		 * @param product
		 */
		function getCustomProductName(product){
			var productName = product.EntityTemplateName;

			if(product.productIndexCount > 0){
				if(product.productIndexCount != 1) {
					productName = productName + ' ' + product.productIndexCount;
				}
			} 

			return productName;			
		}

		/**
		 * function to check if the product is to be removed
		 * @param product
		 */
		function isProductToBeRemoved(product){
			return $scope.tempProductsToBeRemoved.indexOf(product) != -1;
		}

		/**
		 * function to show the remove all product modal dialog
		 */
		function showRemoveAllProductsModal(){
			
			if(isProductAdded($scope.selectedProduct) > 1){
				$rootScope.$broadcast("close-removeProductModal");
				$scope.filteredProducts = $scope.addedProducts.filter(function(item){
					return item.EntityTemplateSk == $scope.selectedProduct.EntityTemplateSk;
				});
				$rootScope.$broadcast("toggle-removeAllProductsModal");
			} else {
				//sometimes productIndexCount wont be set if its from recentProducts or any other list
				$scope.selectedProduct.productIndexCount = 1;
				//$scope.addedProducts.splice($scope.addedProducts.indexOf($scope.selectedProduct),1);
				$scope.addedProducts.splice($scope.addedProducts.map(function(elem) {
					return elem.EntityTemplateSk;
				}).indexOf($scope.selectedProduct.EntityTemplateSk),1);
				newRequestFactory.removeProductSpecificQuestions($scope.selectedProduct);
				var request = newRequestFactory.getRequest();
				request.ResponseTypeSk = null;
				newRequestFactory.setRequest(request);
				$rootScope.$broadcast("close-removeProductModal");
			}
		}

		/**
		 * function to hide the remove all product modal dialog
		 */
		function cancelRemoveAllProductsModal(){
			$rootScope.$broadcast("toggle-removeAllProductsModal");
			$scope.tempProductsToBeRemoved.splice(0,$scope.tempProductsToBeRemoved.length);
		}

		/**
		 * function to remove the selected products
		 */
		function removeSelectedProducts(){
			var newProducts = $scope.addedProducts.filter(function(item){

				var indexToRemove = $scope.tempProductsToBeRemoved.indexOf(item);

				if(indexToRemove == -1){
					return true;
				} else {
					//the item is to be removed
					console.log("selectProductController: going to remove item", item, $scope.removedProductIndexes);
					if(item && item.productIndexCount){
						if(! $scope.removedProductIndexes[item.EntityTemplateSk.toString()]){
							$scope.removedProductIndexes[item.EntityTemplateSk.toString()] = [];
						}
						var alreadyRemovedIndexes =  $scope.removedProductIndexes[item.EntityTemplateSk.toString()];
						alreadyRemovedIndexes.push(item.productIndexCount);
					}
					newRequestFactory.removeProductSpecificQuestions(item);
					return false;
				}			
			});

			$scope.addedProducts.length = 0;
			$scope.addedProducts.push.apply($scope.addedProducts, newProducts);
			var request = newRequestFactory.getRequest();
			request.ResponseTypeSk = null;
			newRequestFactory.setRequest(request);
			console.log('selectProductController: after removing items', $scope.addedProducts,$scope.tempProductsToBeRemoved);
			cancelRemoveAllProductsModal();
		}

		/**
		 * function to add a product 
		 * @param product
		 */
		function addProduct(product){
			$scope.addedProducts.push(product);
			newRequestFactory.addProductSpecificQuestions(product);
			//var request = newRequestFactory.getRequest();
			//request.ResponseTypeSk = null;
			//newRequestFactory.setRequest(request);
		}
		/**
		 * function to remove a product 
		 * @param product
		 */
		function removeProduct(){
			var tempProdToRemove=$scope.addedProducts[$scope.productToRemove];
			$scope.addedProducts.splice($scope.productToRemove, 1);
			newRequestFactory.removeProductSpecificQuestions(tempProdToRemove);
			$scope.productToRemove = -1;
			//var request = newRequestFactory.getRequest();
			//request.ResponseTypeSk = null;
			//newRequestFactory.setRequest(request);
		}
		
		/**
		 * function to add or remove a fav product 
		 * @param product
		 * @param event
		 */
		function addOrRemoveFavoriteProduct(product,event){
			product = $scope.allProducts.filter(function(e){ 
				return e.EntityTemplateSk == product.EntityTemplateSk;
			})[0];
				if(isProductAdded(product) == 0){	
					event.preventDefault();
					event.stopPropagation();
					if(isProductFavorite(product)){
						favoriteProducts.removeProduct(product)
						.then(function(){
							getFavoriteProducts();
						});
					}else{
						favoriteProducts.addProduct(product)
						.then(function(){
							getFavoriteProducts();
						});
					}
				}else{
					
				}
		}

		function blurElementWithId(id){
			$timeout(function() { 
				document.getElementById(id).blur();
			});
		} 
		
		function handleBackButton(){
			var request = newRequestFactory.getRequest();
			request.Products = angular.copy($scope.addedProducts);
			newRequestFactory.setRequest(request);
			//newRequestFactory.updateProductSpecificQuestions();
			broadCastHandleBack();
		}
		
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
		}
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
	}

})();
(function(){
	'use strict';
	
	selectRequiredResponseController.$inject = ['$scope', '$rootScope', 'newRequestFactory'];
	angular.module('ccMobile.requests')
		.controller('selectRequiredResponseController', selectRequiredResponseController);
	
	/**
	 * controller for the required response questions
	 */
	function selectRequiredResponseController($scope, $rootScope, newRequestFactory){
		//variables
		$scope.questionsRequired = newRequestFactory.areQuestionsRequired;
		$scope.selectedCurrency = newRequestFactory.getRequest().CurrencyCode;
		$scope.requiredResponse = newRequestFactory.requiredResponse;
		$scope.request = newRequestFactory.getRequest();
		var selectedProducts = $scope.request.Products || [];
		var configurableProducts = selectedProducts.filter(function(product){
			return product.IsConfigurable;
		});
		
		$scope.isResponseNeeded = configurableProducts.length != 0; 
		//methods
		$scope.handleBackButton = handleBackButton;
		$scope.changeCurrency = changeCurrency;
		$scope.toggleResponse = toggleResponse;
		
		//implementations
		function handleBackButton(){
			broadCastHandleBack();
		}
		
		/**
		 * function to change the currency
		 * @param currency
		 */
		function changeCurrency(currency){
			$scope.selectedCurrency = currency;
			var request = newRequestFactory.getRequest();
			request.CurrencyCode = currency;
			newRequestFactory.setRequest(request);
		}
		
		/**
		 * function to toggle the response
		 * @param response
		 */
		function toggleResponse(response){
			if($scope.request.ResponseTypeSk == response.id){
				$scope.request.ResponseTypeSk = null;
			}else{
				$scope.request.ResponseTypeSk = response.id;
			}
			newRequestFactory.setRequest($scope.request);
		}
		
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
		}
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
	}

})();
(function(){
	'use strict';
	
	uploadFilesController.$inject = ['$scope', '$rootScope'];
	angular.module('ccMobile.requests')
		.controller('uploadFilesController', uploadFilesController);
	
	/**
	 * controller for file upload
	 * 
	 */
	function uploadFilesController($scope, $rootScope){
		$scope.handleBackButton = handleBackButton;
		
		function handleBackButton(){
			broadCastHandleBack();
		}
		
		function broadCastHandleBack(){
			$rootScope.$broadcast("handleBack");
		}
		
		WL.App.overrideBackButton(function(e){
			e.preventDefault();
			handleBackButton();
		});
	}

})();
/**
*  favoriteEndUsers Service 
*
* Description: Provides Metods for adding, removing and getting the favorite Endusers of Loggedin user
*/

(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
	.factory('favoriteEndUsers', favoriteEndUsers);
	
	favoriteEndUsers.$inject = ['$q'];
	function favoriteEndUsers($q){

		var favoriteEndUsers = {
			"addEndUser" : addEndUser,
			"removeEndUser" : removeEndUser,
			"getFavoriteEndUsers" : getFavoriteEndUsers
		};
		
		/**
		 *   function to add end user as favorite
		 *	 @param user - End user to be added to favorite endusers list
		 */
		function addEndUser(user){
			var defered = $q.defer();

			user.loginId = localStorage.getItem("LoginId")+"";
			getEndUser(parseInt(user.PartnerId))
			.then(function(users){
				if(users.length == 0){
					WL.JSONStore.get("favoriteEndUser").add(user)
					.then(function(){
						defered.resolve();
					}, function(){
						defered.resolve();
					});
				}
			}, function(){
				WL.JSONStore.get("favoriteEndUser").add(user)
				.then(function(){
					defered.resolve();
				}, function(){
					defered.resolve();
				});
			});
			return defered.promise;
		}
		
		/**
		 * 	function to get EndUser
		 *	@param PartnerId - End user with given PartnerId is returned
		 */
		function getEndUser(PartnerId){
			var defered = $q.defer();
			
			var collectionName = 'favoriteEndUser';
			var loginId = localStorage.getItem("LoginId")+"";
			
			WL.JSONStore.get(collectionName)
			.find({'PartnerId':PartnerId, "loginId" :loginId}, {})
			.then(function (results) {
				defered.resolve(results);
			})
			.fail(function (errorObject) {
				defered.reject();
			});
			
			return defered.promise;
		}
		
		/**
		 *  Removes provided end user from favorite end users list
		 *	@param user - End user to be removed from favorites list
		 */
		function removeEndUser(user){
			var defered = $q.defer();

			getEndUser(parseInt(user.PartnerId))
			.then(function(users){
				if(users.length != 0){
					WL.JSONStore.get("favoriteEndUser").remove(users)
					.then(function(){
						defered.resolve();
					}, function(){
						defered.resolve();
					});
				}else{
					defered.resolve();
				}
			}, function(){
				defered.resolve();
			});
			return defered.promise;
		}
		
		/**
		 *  Returns all the stored favorite end users of the loggedin User
		 */
		function getFavoriteEndUsers(){
			var defered = $q.defer();
			
			var loginId = localStorage.getItem("LoginId")+"";
			WL.JSONStore.get("favoriteEndUser")
			.find({'loginId':loginId}, {})
			.then(function (results) {
				defered.resolve(results.map(function(e){ return e.json;}));
			})
			.fail(function (errorObject) {
				defered.reject();
			});
			return defered.promise;
		}
		
		return favoriteEndUsers;
	}

})();
/**
*  favoriteProducts Service 
*
* Description: Provides Metods for adding, removing and getting the favorite products of Loggedin user
*/

(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
	.factory('favoriteProducts', favoriteProducts);
	
	favoriteProducts.$inject = ['$q'];
	function favoriteProducts($q){

		var favoriteProducts = {
			"addProduct" : addProduct,
			"removeProduct" : removeProduct,
			"getFavoriteProducts" : getFavoriteProducts
		};
		
		/**
		 *   function to add product as favorite
		 *   @param product - product to be added to favorites list
		 */
		function addProduct(product){
			var defered = $q.defer();
			
			product.loginId = localStorage.getItem("LoginId")+"";
			
			getProduct(parseInt(product.EntityTemplateSk))
			.then(function(products){
				if(products.length == 0){
					WL.JSONStore.get("favoriteProduct").add(product)
					.then(function(){
						defered.resolve();
					}, function(){
						defered.resolve();
					});
				}
				else{
					console.log('cacheService product already present')
				}
			}, function(){
				WL.JSONStore.get("favoriteProduct").add(product)
				.then(function(){
					defered.resolve();
				}, function(){
					defered.resolve();
				});
			});
			return defered.promise;
		}
		
		/**
		 * 	function to get product
		 *	@param EntityTemplateSk - product with given EntityTemplateSk is returned
		 */
		function getProduct(EntityTemplateSk){
			var defered = $q.defer();
			
			var collectionName = 'favoriteProduct';
			var loginId = localStorage.getItem("LoginId")+"";
			
			WL.JSONStore.get(collectionName)
			.find({'EntityTemplateSk':EntityTemplateSk, "loginId" :loginId}, {exact:true})
			.then(function (results) {
				defered.resolve(results);
			})
			.fail(function (errorObject) {
				defered.reject();
			});
			
			return defered.promise;
		}
		
		/**
		 * Removes provided product from favorite products
		 *	@param product - product to be removed from favorites list
		 */
		function removeProduct(product){
			var defered = $q.defer();

			getProduct(parseInt(product.EntityTemplateSk))
			.then(function(products){
				if(products.length != 0){
					WL.JSONStore.get("favoriteProduct").remove(products)
					.then(function(){
						defered.resolve();
					}, function(){
						defered.resolve();
					});
				}else{
					defered.resolve();
				}
			}, function(){
				defered.resolve();
			});
			return defered.promise;
		}
		
		/**
		 *   Returns all the stored favorite products of the loggedin User
		 *   @parma allProducts - allProducts list
		 */
		function getFavoriteProducts(allProducts){
			var defered = $q.defer();
			
			var allProductsIds = allProducts.map(function(e){ return e.EntityTemplateSk;});
			var loginId = localStorage.getItem("LoginId")+"";
			WL.JSONStore.get("favoriteProduct")
			.find({'loginId':loginId}, {exact:true})
			.then(function (results) {
				var validProducts = results.filter(function(product){
					return allProductsIds.indexOf(product.json.EntityTemplateSk) != -1;
				});
				defered.resolve(validProducts.map(function(e){ return e.json;}));
			})
			.fail(function (errorObject) {
				defered.reject();
			});
			return defered.promise;
		}
		
		return favoriteProducts;
	}

})();
/**
*  filterPreferences Service 
*
* Description: Contains initial filter preferences of Quotes
*/

(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
	.factory('filterPreferences', filterPreferences);
	
	function filterPreferences(){
		var filterPreferences = {
			filters : ['-json.ApplUpdateDT'],
			limitTo : 20
		};
		
		return filterPreferences;
	}

})();
/**
*  loginCacheService Service 
*
* Description: Provides Methods for saving, getting and deleting login Tokens
*/
(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
		.factory('loginCacheService', loginCacheService);
	
	function loginCacheService(){
		var loginCacheService = {
			saveLoginToken : saveLoginToken,
			getLoginToken : getLoginToken,
			deleteTokens : deleteTokens
		};
		
		/**
		 *   function save login Tokens
		 *   @param cookie 
		 *   @param sessionId 
		 *   @param emailAddress 
		 */
		function saveLoginToken(cookie, sessionId, emailAddress){
			localStorage.setItem("cookie", cookie);
			localStorage.setItem("sessionId", sessionId);
			localStorage.setItem("emailAddress", emailAddress);
		}
		
		/**
		 *   function get login Tokens
		 */
		function getLoginToken(){
			var cookie = (localStorage.getItem("pdhSessionId")||"")+','+(localStorage.getItem("pdId")||"")+','+(localStorage.getItem("bigIpCookie")||"");
			return {
				"cookie" : cookie,
				"sessionId" : localStorage.getItem("sessionId"),
				"emailAddress" : localStorage.getItem("emailAddress")
			};
		}
		
		/**
		 *   function delete login Tokens
		 */
		function deleteTokens(){
			localStorage.removeItem("cookie");
			localStorage.removeItem("sessionId");
			localStorage.removeItem("emailAddress");
		}
		
		return loginCacheService;
	}
})();
/**
*  productSpecificQuestionsCacheService Service 
*
* Description: Provides methods for getting products requiring Questions and are Questions required for given products
*/
(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
	.factory('productSpecificQuestionsCacheService', productSpecificQuestionsCacheService);
	
	productSpecificQuestionsCacheService.$inject = ['$q'];

	function productSpecificQuestionsCacheService($q){
		var factory = {
			"getProductsRequiringQuestions" : getProductsRequiringQuestions,
			"areQuestionsRequired" : areQuestionsRequired,	
		};
		
		/**
		 *   function to get Product Requiring QUestions
		 */
		function getProductsRequiringQuestions(){
			var productsRequiringQuestions = localStorage.getItem("productsRequiringQuestions");
			if(productsRequiringQuestions != null){
				return JSON.parse(productsRequiringQuestions);
			}else{
				return [];
			}
		}
		
		/**
		 *   function to get are Questions Required for the given products 
		 *   @param prods - Products for which we want check are Questions Required
		 */
		function areQuestionsRequired(prods){
			var products = (prods || []).map(function(item){ return item.EntityTemplateSk;});
			var productsRequiringQuestions = factory.getProductsRequiringQuestions().map(function(item){return item.EntityTemplateSk;});
			
			var productsMatching = products.filter(function(item){
				return productsRequiringQuestions.indexOf(item) != -1;
			});
			return productsMatching.length != 0;
		}
		
		return factory;
	}
	
})();
/**
*  quoteDetailCacheService Service 
*
* Description: Provides methods for getting cached QuoteDetail and updating the cached Quote Detail
*/
(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
		.factory('quoteDetailCacheService',quoteDetailCacheService);
	
	quoteDetailCacheService.$inject = ['$q'];
	function quoteDetailCacheService($q){
		var quoteDetailCacheService = {
				'getQuoteDetail' : getQuoteDetail,
				'updateQuoteDetail' : updateQuoteDetail
		};
		
		/**
		 *   function to get cached Quote Detail
		 *   @param requestRevisionSK - requestRevisionSK of the Request
		 */
		function getQuoteDetail(requestRevisionSK){
			var defered = $q.defer();
			var collectionName = 'quoteDetails';
			WL.JSONStore.get(collectionName)
			.find({'RequestRevisionSK':requestRevisionSK}, {exact:true})
			.then(function (results) {
				defered.resolve(results);
			})
			.fail(function (errorObject) {
				defered.reject();
			});
			
			return defered.promise;
		}
		
		/**
		 *   function to get cached Quote Detail
		 *   @param quoteDetail - updated quoteDetail of the Request
		 *   @param requestRevisionSK - requestRevisionSK of the Request
		 */
		function updateQuoteDetail(quoteDetail, requestRevisionSK){
			var defered = $q.defer();
			
			quoteDetail.lastRefreshed = (new Date()).getTime();
			if(quoteDetail.entityFiles != null){
				for(var i=0; i < quoteDetail.entityFiles.length; i++){
					var date = new Date();
					var offset = date.getTimezoneOffset()*60*1000;
					quoteDetail.entityFiles[i].LastUpdate = (new Date(quoteDetail.entityFiles[i].LastUpdate)).getTime() + offset;
				}
			}
			var LoginId = localStorage.LoginId+"";
			var fullName = localStorage.FullName+"";
			if(quoteDetail.notes != null){
				for(var j=0; j < quoteDetail.notes.length; j++){
					var note = quoteDetail.notes[j];
					if(note.isInternalUser){
						if(note.CreateUserId == LoginId){
							quoteDetail.notes[j].CreateUserName = fullName;
						}
					}
				}
			}
			
			quoteDetail.RequestRevisionSK = parseInt(requestRevisionSK);
			if(quoteDetail.status != null){
				//quoteDetail.status = quoteDetail.status.split("/")[1];
			}
			
			
			getQuoteDetail(requestRevisionSK)
			.then(function(results){
				if(results.length > 0){
					console.log("replacing quote");
					results[0].json = quoteDetail;
					WL.JSONStore.get("quoteDetails").replace(results, {});
					defered.resolve();
				}else{
					console.log("adding quote");
					WL.JSONStore.get("quoteDetails").add(quoteDetail);
					defered.resolve();
				}
				
			}, function(){
				WL.JSONStore.get("quoteDetails").add(quoteDetail);
				defered.resolve();
			});
			
			return defered.promise;
		}
		
		return quoteDetailCacheService;
	}
})();
/**
*  quoteListCacheService Service 
*
* Description: Provides methods for getting cached RequestsList and updating the cached RequestsList
*/
(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
		.factory('quoteListCacheService',quoteListCacheService);
	
	quoteListCacheService.$inject = ['$q'];
	
	function quoteListCacheService($q){
		var quoteListCacheService = {
				'getQuotes' : getQuotes,
				'updateQuotes' : updateQuotes
		};
		
		/**
		 *   function to get RequestsList
		 */

		function getQuotes(){
			var defered = $q.defer();

			WL.JSONStore.get("quotes")
			.findAll()
			.then(function (results) {
				defered.resolve(results);
			})
			.fail(function (errorObject) {
				defered.reject();
			});
			return defered.promise;
		}
		
		/**
		 *   function to update cached RequestsList
		 *   @param data - updated data of the RequestsList
		 */
		function updateQuotes(data){
			var defered = $q.defer();
			for(var i=0; i < data.length; i++){
				if(data[i].ApplCreateDT != null){
					data[i].ApplCreateDT = (new Date(data[i].ApplCreateDT.split("T")[0])).getTime();
				}	
				if(data[i].ApplUpdateDT != null){
					data[i].ApplUpdateDT = (new Date(data[i].ApplUpdateDT.split("T")[0])).getTime();
				}
				if(data[i].WorkflowStatusTX != null){
					//data[i].WorkflowStatusTX = data[i].WorkflowStatusTX.split("/")[1] || data[i].WorkflowStatusTX;
				}else{
					data[i].WorkflowStatusTX = undefined;
				}
			}
			var changeOptions = {
				    'replaceCriteria' : ['RequestNO'],
				    'addNew' : true,
				    'markDirty' : false
				  };
			
			WL.JSONStore.get("quotes")
			.clear()
			.then(function(){
				addData();
			})
			.fail(function (errorObject) {
				addData();
			});
			
			function addData(){
				WL.JSONStore.get("quotes").change(data, changeOptions)
				.then(function () {
					defered.resolve();
				})
				.fail(function (errorObject) {
					defered.reject("offline data failed");
				});
			}
			
			return defered.promise;
		}
		
		return quoteListCacheService;
	}
})();
/**
*  recentNotificationEmails Service 
* 
* Description: Provides methods for getting Recent Notification emails List and adding Emails to it
*/
(function(){
	'use strict';
	
	angular.module('ccMobile.requests')
	.factory('recentNotificationEmails', recentNotificationEmails);
	
	recentNotificationEmails.$inject = ['$q'];
	function recentNotificationEmails($q){

		var recentNotificationEmails = {
			"addEmail" : addEmail,
			"getRecentEmails" : getRecentEmails
		};
		
		/**
		 *   function to add email to Recent Notification Emails List
		 *   @param emailId - emailId to be added to Recent Notification Emails List
		 */
		function addEmail(emailId){
			var defered = $q.defer();
			var email = {
				"email" : emailId,
				"loginId" : localStorage.getItem("LoginId")+""
			};
						
			getEmail(emailId)
			.then(function(emails){
				if(emails.length == 0){
					WL.JSONStore.get("recentNotificationEmails").add(email)
					.then(function(){
						defered.resolve();
					}, function(){
						defered.resolve();
					});
				}
			}, function(){
				WL.JSONStore.get("recentNotificationEmails").add(email)
				.then(function(){
					defered.resolve();
				}, function(){
					defered.resolve();
				});
			});
			return defered.promise;
		}
		
		/**
		 *   function to get email from Recent Notification Emails List
		 *   @param emailId - emailId to get from Recent Notification Emails List
		 */
		function getEmail(emailId){
			var defered = $q.defer();
			
			var collectionName = 'recentNotificationEmails';
			var loginId = localStorage.getItem("LoginId")+"";
			
			WL.JSONStore.get(collectionName)
			.find({'email':emailId, "loginId" :loginId}, {exact:true})
			.then(function (results) {
				defered.resolve(results);
			})
			.fail(function (errorObject) {
				defered.reject();
			});
			
			return defered.promise;
		}
		
		
		/**
		 *   function to get Recent Notification Emails List
		 */
		function getRecentEmails(){
			var defered = $q.defer();
			
			var loginId = localStorage.getItem("LoginId")+"";
			
			WL.JSONStore.get("recentNotificationEmails")
			.find({'loginId':loginId}, {exact:true})
			.then(function (results) {
				defered.resolve(results.map(function(e){ return e.json;}));
			})
			.fail(function (errorObject) {
				defered.reject();
			});
			return defered.promise;
		}
		
		return recentNotificationEmails;
	}

})();